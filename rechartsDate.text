/* eslint-disable react/no-array-index-key */
/* eslint-disable linebreak-style */

'use client';

import React, { useEffect, useState } from 'react';
import { Row } from 'react-bootstrap';
import { useTranslation } from 'react-i18next';
import { BounceLoader } from 'react-spinners';
import { connect } from 'react-redux';
import moment from 'moment';
import {
  concat, uniqBy, sortBy, findIndex, slice, isEmpty,
} from 'lodash';
import {
  BarChart,
  Bar,
  XAxis,
  YAxis,
  Tooltip,
  ResponsiveContainer,
} from 'recharts';
import i18next from '../../i18n';
import { setSearchData, setDataForSchedule } from '../../redux/routes.redux';
import { fetchAvailability, fetchFlights } from '../../redux/flight.redux';
import {
  getDateForScheduler,
  getLanguageCode,
  formatCurrency,
} from '../../helpers/utilities';
import { WORKFLOW } from '../../constants/common';
import styles from './styles.scss';

function SampleNextArrow(props: any) {
  const { onClick } = props;
  return (
    <div
      className="slick-nav snav-next"
      tabIndex={0}
      role="button"
      onClick={onClick}
    >
      <i className="fo-icon icon-next" />
    </div>
  );
}

function SamplePrevArrow(props: any) {
  const { onClick, disabled } = props;
  let prevProps = {};
  if (!disabled) {
    prevProps = {
      onClick,
      role: 'button',
      tabIndex: 0,
    };
  }
  return (
    <div
      className={`slick-nav snav-prev ${disabled ? 'disabled' : ''}`}
      {...prevProps}
    >
      <i className="fo-icon icon-back" />
    </div>
  );
}

function sliceByIndex(dates: any, index: any) {
  let findex = findIndex(dates, (date: any) => date.dateObj === index);
  findex = findex - 3 >= 2 ? findex - 3 : 0;
  const eIndex = dates.length - findex >= 4 ? findex + 7 : findex + 4;
  return {
    sIndex: findex,
    showDate: slice(dates, findex, eIndex),
    eIndex,
  };
}

function DateSchedule(props: any) {
  const {
    inboundAvailability,
    outboundAvailability,
    resultFor,
    isFetchingDate,
    query,
    flightQuery,
    hasDates,
    dispatch,
    scheduleErrors,
    actionState,
    urlQuery,
    exchangeRate,
    selectedCurrencyCode,
    resetReduxState,
    isFlightFetching,
  } = props;
  const { t } = useTranslation();
  const [dates, setDates] = useState([]);
  const [cmpQuery, setCmpQuery] = useState(query);
  const [activeIndex, setActiveIndex] = useState(0);
  const [selectedIndex, setselectedIndex] = useState(0);

  if (selectedIndex && query && resultFor === 'outBound' && hasDates) {
    const { journeyInfo } = query.searchCriteria || { journeyInfo: null };
    if (selectedIndex !== journeyInfo.routeInfo[0].travelDate) {
      setActiveIndex(journeyInfo.routeInfo[0].travelDate);
      setselectedIndex(journeyInfo.routeInfo[0].travelDate);
    }
  }

  if (selectedIndex && query && resultFor === 'inBound' && hasDates) {
    const { journeyInfo } = query.searchCriteria || { journeyInfo: null };
    if (selectedIndex !== journeyInfo.routeInfo[1].travelDate) {
      setActiveIndex(journeyInfo.routeInfo[1].travelDate);
      setselectedIndex(journeyInfo.routeInfo[1].travelDate);
    }
  }

  const language = getLanguageCode();
  const [prevButtonprop, setPrevButtonprop] = useState(false);

  useEffect(() => {
    if (!hasDates && !isEmpty(scheduleErrors) && resultFor === 'inBound') {
      if (scheduleErrors[0].code === 1007) {
        setPrevButtonprop(true);
      }
    } else if (
      !hasDates
      && !isEmpty(scheduleErrors)
      && resultFor === 'outBound'
    ) {
      if (scheduleErrors[0].code === 1009) {
        setPrevButtonprop(true);
      }
    }
  }, [scheduleErrors]);

  useEffect(() => {
    if (query && !resetReduxState) {
      const { journeyInfo } = query.searchCriteria || { journeyInfo: null };
      if (resultFor === 'inBound') {
        if (hasDates) {
          let datess: any = concat(
            dates,
            getDateForScheduler(inboundAvailability),
          );
          datess = uniqBy(datess, 'dateObj');
          datess = sortBy(datess, (date: any) => new Date(date.dateObj));
          setDates(datess);
          setActiveIndex(
            typeof journeyInfo.routeInfo[1] !== 'undefined'
              ? journeyInfo.routeInfo[1].travelDate
              : '',
          );
          setselectedIndex(
            typeof journeyInfo.routeInfo[1] !== 'undefined'
              ? journeyInfo.routeInfo[1].travelDate
              : '',
          );
        }
      } else if (resultFor === 'outBound' && hasDates) {
        let datess: any = concat(
          dates,
          getDateForScheduler(outboundAvailability),
        );
        datess = uniqBy(datess, 'dateObj');
        datess = sortBy(datess, (date: any) => new Date(date.dateObj));
        setDates(datess);
        setActiveIndex(journeyInfo.routeInfo[0].travelDate);
        if (selectedIndex === 0) {
          setselectedIndex(journeyInfo.routeInfo[0].travelDate);
        }
      }
    }
  }, [inboundAvailability, outboundAvailability]);

  useEffect(() => {
    if (!isEmpty(query) && !resetReduxState) {
      const tmpQuery: any = query;
      const tmpFQuery: any = flightQuery;
      tmpQuery.languageCode = language;
      tmpFQuery.languageCode = language;
      dispatch(setSearchData(tmpFQuery));
      dispatch(setDataForSchedule(tmpQuery));
      dispatch(fetchFlights(tmpFQuery));
    }
  }, [language]);

  useEffect(() => {
    if (!resetReduxState) {
      dispatch(fetchAvailability(cmpQuery));
    }
  }, [JSON.stringify(cmpQuery)]);

  const fetchdate = ({ dateObj, dateCount, isAfter }: any) => {
    const tmpQuery: any = query;
    const { searchCriteria: sCriteria } = tmpQuery;
    if (resultFor === 'inBound') {
      sCriteria.journeyInfo.routeInfo[1].travelDate = dateObj;
      sCriteria.journeyInfo.routeInfo[1].schedule = {
        before: !isAfter ? dateCount : 0,
        after: isAfter ? dateCount : 0,
      };
    } else {
      sCriteria.journeyInfo.routeInfo[0].travelDate = dateObj;
      sCriteria.journeyInfo.routeInfo[0].schedule = {
        before: !isAfter ? dateCount : 0,
        after: isAfter ? dateCount : 0,
      };
    }
    tmpQuery.searchCriteria = sCriteria;
    setCmpQuery(tmpQuery);
    dispatch(setDataForSchedule(tmpQuery));
  };

  const chooseDate = ({ dateObj }: any) => {
    if (!isFlightFetching) {
      const tmpQuery: any = query;
      const tmpFQuery: any = flightQuery;
      const { searchCriteria: sCriteria } = tmpQuery;
      const { searchCriteria: sfCriteria } = tmpFQuery;
      if (resultFor === 'inBound') {
        sCriteria.journeyInfo.routeInfo[1].travelDate = dateObj;
        sfCriteria.journeyInfo.routeInfo[1].travelDate = dateObj;
      } else {
        const { journeyType } = sCriteria.journeyInfo;
        if (
          journeyType === 2
          && moment(dateObj).isAfter(sCriteria.journeyInfo.routeInfo[1].travelDate)
        ) {
          sCriteria.journeyInfo.routeInfo[0].travelDate = dateObj;
          sfCriteria.journeyInfo.routeInfo[0].travelDate = dateObj;
          sCriteria.journeyInfo.routeInfo[1].travelDate = dateObj;
          sfCriteria.journeyInfo.routeInfo[1].travelDate = dateObj;
        } else {
          sCriteria.journeyInfo.routeInfo[0].travelDate = dateObj;
          sfCriteria.journeyInfo.routeInfo[0].travelDate = dateObj;
        }
      }
      tmpQuery.searchCriteria = sCriteria;
      tmpFQuery.searchCriteria = sCriteria;
      dispatch(setSearchData(tmpFQuery));
      dispatch(fetchFlights(tmpFQuery));
      setselectedIndex(dateObj);
    }
  };

  const datesToShow = sliceByIndex(dates, activeIndex);

  const onNextClick = (showigDate: any) => {
    const currentIndex = findIndex(
      dates,
      (date: any) => date.dateObj === activeIndex,
    );
    const { dateObj } = dates[currentIndex + 1];
    setActiveIndex(dateObj);
    if (showigDate.eIndex + 1 >= dates.length - 1) {
      fetchdate({ dateObj, dateCount: 7, isAfter: true });
    }
  };

  const onPrevClick = (showigDate: any) => {
    const currentIndex = findIndex(
      dates,
      (date: any) => date.dateObj === activeIndex,
    );
    const { dateObj } = dates[currentIndex - 1];
    setActiveIndex(dateObj);
    if (showigDate.sIndex - 1 <= 1) {
      fetchdate({ dateObj, dateCount: 7, isAfter: false });
    }
  };

  if (!isFetchingDate && dates.length < 1) {
    return (
      <div className="no-mar-right-left row">
        <div className="bor-right no_flights col">
          {t('FlightResult.lblNoFlight')}
        </div>
      </div>
    );
  }

  // Transform dates for chart
  const chartData = dates.map((date: any) => ({
    name: moment(date.dateObj).format('MMM DD'),
    price: date.price,
  }));

  return (
    <>
      <div style={{ width: '100%' }}>
        <p>Flight Prices Chart</p>
        <ResponsiveContainer width="100%" height={300}>
          <BarChart data={chartData}>
            <XAxis dataKey="name" />
            <YAxis />
            <Tooltip formatter={(value: any) => `$${value}`} />
            <Bar dataKey="price" fill="#8884d8" />
          </BarChart>
        </ResponsiveContainer>
      </div>
      <div className={styles.dateScheduler}>
        {isFetchingDate ? (
          <div className="d-flex justify-content-center">
            <BounceLoader size={60} color="#123abc" loading={isFetchingDate} />
          </div>
        ) : (
          <Row>
            <SamplePrevArrow
              disabled={prevButtonprop}
              onClick={() => onPrevClick(datesToShow)}
            />
            <div className="dateBinder">
              {datesToShow.showDate.map((avDate: any) => {
                const {
                  price,
                  dateObj,
                  isFlightAvailable,
                  currency,
                  isSoldOut,
                } = avDate;
                let classNamee = `${styles.dateItem}${
                  selectedIndex === dateObj ? ' selected' : ''
                }`;
                let clickProps = {};
                let flightMsg = t('FlightResult.lblNoFlight');
                if (isFlightAvailable && !isSoldOut) {
                  if (resultFor === 'inBound') {
                    const tmpQuery: any = query;
                    const { searchCriteria: sCriteria } = tmpQuery;
                    const obDate = sCriteria.journeyInfo.routeInfo[0].travelDate;
                    if (
                      (moment(obDate) <= moment(dateObj)
                        && moment() <= moment(dateObj))
                      || moment(obDate).isSame(dateObj, 'day')
                    ) {
                      clickProps = {
                        onClick: () => chooseDate(avDate),
                      };
                      classNamee = `${classNamee} available`;
                    } else {
                      classNamee = `${classNamee} unavailable`;
                    }
                  } else {
                    let isAvail = moment() <= moment(dateObj)
                      || moment().isSame(dateObj, 'day');
                    clickProps = isAvail
                      ? {
                        onClick: () => chooseDate(avDate),
                      }
                      : {};
                    if (actionState === WORKFLOW.MMB) {
                      const { action, departureDate, returnDate } = urlQuery;
                      if (action === 'return') {
                        isAvail = moment(dateObj).isSameOrAfter(departureDate);
                      } else if (
                        action === 'departure'
                        && !isEmpty(returnDate)
                      ) {
                        isAvail = moment(dateObj).isSameOrBefore(returnDate);
                      }
                    }
                    classNamee = `${classNamee}${
                      isAvail ? ' available' : ' unavailable'
                    }`;
                  }
                } else if (isSoldOut) {
                  classNamee = `${classNamee} unavailable`;
                  flightMsg = t('FlightResult.lblSoldout');
                } else {
                  classNamee = `${classNamee} unavailable`;
                  flightMsg = t('FlightResult.lblNoFlight');
                }
                const newDatee = moment(dateObj, 'YYYY-MM-DD').locale(
                  i18next.language,
                );
                const newDateeFrmt = newDatee.format('ddd DD, MMM');
                return (
                  <div
                    className={classNamee}
                    key={`${avDate.date}-${avDate.price}`}
                  >
                    <div
                      role="button"
                      tabIndex={0}
                      className={styles.dateList}
                      {...clickProps}
                    >
                      <label>{newDateeFrmt}</label>
                      <span>
                        {!isFlightAvailable || isSoldOut
                          ? flightMsg
                          : formatCurrency(
                            price,
                            currency,
                            exchangeRate,
                            selectedCurrencyCode,
                          )}
                      </span>
                    </div>
                  </div>
                );
              })}
            </div>
            <SampleNextArrow onClick={() => onNextClick(datesToShow)} />
          </Row>
        )}
      </div>
    </>
  );
}

const mapStateToProps = (state: any) => ({
  query: state.routes.dateSchduleData,
  flightQuery: state.routes.searchData,
  outboundAvailability: state.flight.outboundAvailability,
  isFetchingDate: state.flight.isFetchingDate,
  isFlightFetching: state.flight.isFetching,
  inboundAvailability: state.flight.inboundAvailability,
  hasDates: state.flight.hasDates,
  scheduleErrors: state.flight.scheduleErrors,
  actionState: state.workflow.actionState,
  urlQuery: state.routes.query,
  exchangeRate: state.totalAmount.exchangeRate,
  selectedCurrencyCode: state.totalAmount.selectedCurrencyCode,
});

export default connect(mapStateToProps)(DateSchedule);
