/* eslint-disable no-case-declarations */
import * as _ from 'lodash';
import axios from 'axios';
import { AddontInitState, IAddon } from './initialState';
import { updateAuth } from './auth.redux';
import { execute } from '../helpers/ApiInterface';
import { setAddonSegInfo, checkPetPurchase } from '../helpers/utilities';
import { updateTotalPrice } from './price.redux';
import {
  setBaggageMenu,
  setServiceMenu,
  setSeatMenu,
  deSelectServiceMenu,
  selectAllBaggagers,
  resetServiceAddonInBaggagePage,
} from './summaryLeftMenu.redux';
import {
  WORKFLOW,
  ADDON_NAME,
  ADDON_SERVICE_DISPLAY_NAME,
  PAX_TYPE,
  BAGGAGE_PAGE_ADDONS,
} from '../constants/common';

interface IAddonsResponse {
  token: string;
  availableAddons: any,
  flightAddon: any,
  result: {
    isSuccess: boolean;
    msgs: Array<any>;
  };
}
interface ISelectdAddonsResponse {
  token: string;
  selectedAddons: [],
  result: {
    isSuccess: boolean;
    msgs: Array<any>;
  };
}


// TYPES
export const SET_PET_PURCHASED = 'addon/SET_PET_PURCHASED';
export const DESELECT_SERVICE_BY_SEGMENT = 'addon/DESELECT_SERVICE_BY_SEGMENT';
export const DESELECT_SERVICE = 'addon/DESELECT_SERVICE';
export const FETCHING_ADDONS = 'addon/FETCHING_ADDONS';
export const RESET_SELECTED_ADDONS = 'addon/RESET_SELECTED_ADDONS';
export const FETCH_ADDONS_SUCCESS = 'addon/FETCH_ADDONS_SUCCESS';
export const FETCH_ADDONS_FAILURE = 'addon/FETCH_ADDONS_FAILURE';
export const UPDATE_ADDONS_SUCCESS = 'addon/UPDATE_ADDONS_SUCCESS';
export const SELECT_ADDONS_SUCCESS = 'addon/SELECT_ADDONS_SUCCESS';
export const SET_EMPTY_ADDONS = 'addon/SET_EMPTY_ADDONS';
export const SELECT_BAGGAGE = 'addon/SELECT_BAGGAGE';
export const REMOVE_BAGGAGE = 'addon/REMOVE_BAGGAGE';
export const SELECT_SAME_BAGGAGE = 'addon/SELECT_SAME_BAGGAGE';
export const REMOVE_ALL_BAGGAGES = 'addon/REMOVE_ALL_BAGGAGES';
export const SELECT_SEAT = 'addon/SELECT_SEAT';
export const SELECT_MEAL = 'addon/SELECT_MEAL';
export const SELECT_SPCLREQUEST = 'addon/SELECT_SPCLREQUEST';
export const REMOVE_MEAL = 'addon/REMOVE_MEAL';
export const REMOVE_SPCLREQUEST = 'addon/REMOVE_SPCLREQUEST';
export const SELECT_SERVICE = 'addon/SELECT_SERVICE';
export const SELECT_SMS_SERVICE = 'addon/SELECT_SMS_SERVICE';
export const REMOVE_SERVICE = 'addon/REMOVE_SERVICE';
export const SET_IS_FETCHING = 'addon/SET_IS_FETCHING';
export const INIT_BAGGAGES = 'addon/INIT_BAGGAGES';
export const INIT_SEATS = 'addon/INIT_SEATS';
export const SELECT_BAGGAGE_ALL = 'addon/SELECT_BAGGAGE_ALL';
export const ADDONS_UNAVAILABLE = 'checkin/ADDONS_UNAVAILABLE';
export const FETCH_ADDONS_CLUB_DATA = 'checkin/FETCH_ADDONS_CLUB_DATA';
export const SELECT_ADDONS_CLUB = 'checkin/SELECT_ADDONS_CLUB';

export const SET_ADDON_BAGGAGE_PAGE_SAME_BOTH_WAYS = 'addon/SET_ADDON_BAGGAGE_PAGE_SAME_BOTH_WAYS';
export const INIT_BOTHWAY_SETTINGS = 'addon/INIT_BOTHWAY_SETTINGS';
export const UPDATE_BOTHWAY_SETTINGS = 'addon/UPDATE_BOTHWAY_SETTINGS';

const journeyHasAdvantageCbinClass = (cabinSettings: any) => {
  const advatageCabin = _.find(cabinSettings, segs => segs.cabinClass === 'AD');
  return _.isEmpty(advatageCabin);
};

export const updateBaggagePageAddonsForBothways = (selectedAddons: any) => async (
  dispatch: Function,
) => {
  dispatch({
    type: SET_ADDON_BAGGAGE_PAGE_SAME_BOTH_WAYS,
    selectedAddons,
  });
  dispatch(updateTotalPrice());
  dispatch(resetServiceAddonInBaggagePage());
};

export const initBothWaySettings = (paxSettings: any) => (dispatch: Function) => {
  dispatch({
    type: INIT_BOTHWAY_SETTINGS,
    sameForBothBaggagePaxSettings: paxSettings,
    bothPaxSettingsDone: true,
  });
};

export const updateBothWaysPropsSettings = (paxSettings: any) => (dispatch: Function) => {
  dispatch({
    type: UPDATE_BOTHWAY_SETTINGS,
    sameForBothBaggagePaxSettings: paxSettings,
  });
};

function setupBaggagePriority(addon: any, currentFlightKey: any, pax: any, anotherFlights: any) {
  const {
    baggagePriority,
  } = addon.availableAddons;

  const baggagePriorities = addon.selectedAddons.baggagePriority;

  const baggagePriorityOnSegmentByPax = baggagePriorities.find(
    (x: any) => x.flightKey === currentFlightKey && x.paxKey === pax,
  );

  const newBaggagePriority = baggagePriorities.filter((x: any) => x.paxKey !== pax);
  if (baggagePriorityOnSegmentByPax) {
    newBaggagePriority.push(baggagePriorityOnSegmentByPax);
  }

  for (let i = 0; i < anotherFlights.length; i += 1) {
    const anotherFlight = anotherFlights[i];
    const baggagePriorityAvailable = baggagePriority.find(
      (x: any) => x.flightKey === anotherFlight.flightKey,
    );

    if (baggagePriorityAvailable && baggagePriorityAvailable.addOnAvailInfo.length > 0) {
      const addOnAvailInfo = baggagePriorityAvailable.addOnAvailInfo[0];

      if (
        addOnAvailInfo.segmentKeyRef.find((x: any) => x === anotherFlight.segmentKey)
        && !_.isEmpty(baggagePriorityOnSegmentByPax)
      ) {
        const deepCopy = Object.assign({}, baggagePriorityOnSegmentByPax);
        deepCopy.flightKey = anotherFlight.flightKey;
        deepCopy.segmentKey = anotherFlight.segmentKey;
        deepCopy.price = addOnAvailInfo.priceInfo.unitPrice;
        deepCopy.addonKey = addOnAvailInfo.addonKey;
        deepCopy.paxKey = pax;
        newBaggagePriority.push(deepCopy);
      }
    }
  }

  return newBaggagePriority || [];
}

function setupBabyTrolley(addon: any, currentFlightKey: any, pax: any, anotherFlights: any) {
  const {
    babyTrolley,
  } = addon.availableAddons;

  const babyTrolleies = addon.selectedAddons.babyTrolley;

  const babyTrolleyOnSegmentByPax = babyTrolleies.find(
    (x: any) => x.flightKey === currentFlightKey && x.paxKey === pax,
  );

  const newBabyTrolley = babyTrolleies.filter((x: any) => x.paxKey !== pax);
  if (babyTrolleyOnSegmentByPax) {
    newBabyTrolley.push(babyTrolleyOnSegmentByPax);
  }

  for (let i = 0; i < anotherFlights.length; i += 1) {
    const anotherFlight = anotherFlights[i];
    const babyTrolleyAvailable = babyTrolley.find(
      (x: any) => x.flightKey === anotherFlight.flightKey,
    );

    if (babyTrolleyAvailable && babyTrolleyAvailable.addOnAvailInfo.length > 0) {
      const addOnAvailInfo = babyTrolleyAvailable.addOnAvailInfo[0];

      if (
        addOnAvailInfo.segmentKeyRef.find((x: any) => x === anotherFlight.segmentKey)
        && !_.isEmpty(babyTrolleyOnSegmentByPax)
      ) {
        const deepCopy = Object.assign({}, babyTrolleyOnSegmentByPax);
        deepCopy.flightKey = anotherFlight.flightKey;
        deepCopy.segmentKey = anotherFlight.segmentKey;
        deepCopy.price = addOnAvailInfo.priceInfo.unitPrice;
        deepCopy.addonKey = addOnAvailInfo.addonKey;
        deepCopy.paxKey = pax;
        newBabyTrolley.push(deepCopy);
      }
    }
  }

  return newBabyTrolley || [];
}

function setupBaggageGuarantee(addon: any, currentFlightKey: any, pax: any, anotherFlights: any) {
  const {
    baggageGuarantee,
  } = addon.availableAddons;

  const seletecdBaggageGuarantees = addon.selectedAddons.baggageGuarantee;

  const baggageGuaranteeOnSegmentByPax = seletecdBaggageGuarantees.find(
    (x: any) => x.flightKey === currentFlightKey && x.paxKey === pax,
  );

  const newBaggageGuarantees = seletecdBaggageGuarantees.filter((x: any) => x.paxKey !== pax);
  if (baggageGuaranteeOnSegmentByPax) {
    newBaggageGuarantees.push(baggageGuaranteeOnSegmentByPax);
  }

  for (let i = 0; i < anotherFlights.length; i += 1) {
    const anotherFlight = anotherFlights[i];
    const baggageGuaranteeAvailable = baggageGuarantee.find(
      (x: any) => x.flightKey === anotherFlight.flightKey,
    );

    if (baggageGuaranteeAvailable && baggageGuaranteeAvailable.addOnAvailInfo.length > 0) {
      const addOnAvailInfo = baggageGuaranteeAvailable.addOnAvailInfo[0];
      if (
        addOnAvailInfo.segmentKeyRef.find((x: any) => x === anotherFlight.segmentKey)
        && !_.isEmpty(baggageGuaranteeOnSegmentByPax)
      ) {
        const deepCopyBaggageGuarantee = Object.assign({}, baggageGuaranteeOnSegmentByPax);
        deepCopyBaggageGuarantee.flightKey = anotherFlight.flightKey;
        deepCopyBaggageGuarantee.segmentKey = anotherFlight.segmentKey;
        deepCopyBaggageGuarantee.price = addOnAvailInfo.priceInfo.unitPrice;
        deepCopyBaggageGuarantee.addonKey = addOnAvailInfo.addonKey;
        deepCopyBaggageGuarantee.paxKey = pax;
        newBaggageGuarantees.push(deepCopyBaggageGuarantee);
      }
    }
  }

  return newBaggageGuarantees || [];
}

// function setupFlyOnePriority(addon: any, currentFlightKey: any, pax: any, anotherFlights: any) {
//   const {
//     flyOnePriority,
//   } = addon.availableAddons;

//   const flyOnePriorities = addon.selectedAddons.flyOnePriority;

//   const flyOnePriorityOnSegmentByPax = flyOnePriorities.find(
//     (x: any) => x.flightKey === currentFlightKey && x.paxKey === pax,
//   );

//   const newFlyOnePriorities = flyOnePriorities.filter((x: any) => x.paxKey !== pax);
//   if (flyOnePriorityOnSegmentByPax) {
//     newFlyOnePriorities.push(flyOnePriorityOnSegmentByPax);
//   }

//   for (let i = 0; i < anotherFlights.length; i += 1) {
//     const anotherFlight = anotherFlights[i];
//     const flyOnePriorityAvailable = flyOnePriority.find(
//       (x: any) => x.flightKey === anotherFlight.flightKey,
//     );

//     if (flyOnePriorityAvailable && flyOnePriorityAvailable.addOnAvailInfo.length > 0) {
//       const addOnAvailInfo = flyOnePriorityAvailable.addOnAvailInfo[0];

//       if (
//         addOnAvailInfo.segmentKeyRef.find((x: any) => x === anotherFlight.segmentKey)
//         && !_.isEmpty(flyOnePriorityOnSegmentByPax)
//       ) {
//         const deepCopy = Object.assign({}, flyOnePriorityOnSegmentByPax);
//         deepCopy.flightKey = anotherFlight.flightKey;
//         deepCopy.segmentKey = anotherFlight.segmentKey;
//         deepCopy.price = addOnAvailInfo.priceInfo.unitPrice;
//         deepCopy.addonKey = addOnAvailInfo.addonKey;
//         deepCopy.paxKey = pax;
//         newFlyOnePriorities.push(deepCopy);
//       }
//     }
//   }

//   return newFlyOnePriorities || [];
// }

function setuplargeCabinBag(addon: any, currentFlightKey: any, pax: any, anotherFlights: any) {
  const {
    largeCabinBag,
  } = addon.availableAddons;

  const flyOnePriorities = addon.selectedAddons.largeCabinBag;

  const largeCabinBagOnSegmentByPax = flyOnePriorities.find(
    (x: any) => x.flightKey === currentFlightKey && x.paxKey === pax,
  );

  const newFlyOnePriorities = flyOnePriorities.filter((x: any) => x.paxKey !== pax);
  if (largeCabinBagOnSegmentByPax) {
    newFlyOnePriorities.push(largeCabinBagOnSegmentByPax);
  }

  for (let i = 0; i < anotherFlights.length; i += 1) {
    const anotherFlight = anotherFlights[i];
    const largeCabinBagAvailable = largeCabinBag.find(
      (x: any) => x.flightKey === anotherFlight.flightKey,
    );

    if (largeCabinBagAvailable && largeCabinBagAvailable.addOnAvailInfo.length > 0) {
      const addOnAvailInfo = largeCabinBagAvailable.addOnAvailInfo[0];

      if (
        addOnAvailInfo.segmentKeyRef.find((x: any) => x === anotherFlight.segmentKey)
        && !_.isEmpty(largeCabinBagOnSegmentByPax)
      ) {
        const deepCopy = Object.assign({}, largeCabinBagOnSegmentByPax);
        deepCopy.flightKey = anotherFlight.flightKey;
        deepCopy.segmentKey = anotherFlight.segmentKey;
        deepCopy.price = addOnAvailInfo.priceInfo.unitPrice;
        deepCopy.addonKey = addOnAvailInfo.addonKey;
        deepCopy.paxKey = pax;
        newFlyOnePriorities.push(deepCopy);
      }
    }
  }

  return newFlyOnePriorities || [];
}

// ACTIONS
export const canPurchasePet = (hasPet: boolean) => (dispatch: Function) => dispatch({
  type: SET_PET_PURCHASED,
  canPurchasePet: hasPet,
});

export const resetAddons = () => (dispatch: Function) => {
  dispatch({
    type: RESET_SELECTED_ADDONS,
    newState: AddontInitState,
  });
  dispatch(updateTotalPrice());
};

export const fetchingAddons = () => (dispatch: Function) => {
  dispatch(resetAddons());
  dispatch({
    type: FETCHING_ADDONS,
    isFetching: true,
  });
};

export const fetchAddonsCheckin = (data: any) => async (dispatch: Function) => {
  const { availableAddons, result } = data;
  if (!_.isEmpty(availableAddons)) {
    const {
      baggage,
      seats,
      meals,
      // flyOnePriority = [],
      largeCabinBag = [],
      priorityNotification = [],
      changeBaggage = [],
      earlyCheckIn = [],
      automatedCheckIn = [],
      airportCheckIn = [],
      tmpBaggage = [],
      changeFlex,
      fareLock,
      baggagePriority,
      baggageGuarantee,
      sportsEquipment,
      addNameLater,
      onTimeGuarantee,
      smsItinerary,
      covid,
      pets,
      babyTrolley,
      specialRequest,
      clubAnnualFee,
    } = availableAddons;
    console.log(data, 'datadata')
    dispatch({
      type: FETCH_ADDONS_SUCCESS,
      isFetching: false,
      availableAddons: {
        seats,
        meals,
        baggage,
        // flyOnePriority,
        largeCabinBag,
        priorityNotification,
        baggagePriority,
        changeBaggage,
        earlyCheckIn,
        baggageGuarantee,
        automatedCheckIn,
        changeFlex,
        fareLock,
        sportsEquipment,
        airportCheckIn,
        addNameLater,
        tmpBaggage,
        onTimeGuarantee,
        smsItinerary,
        covid,
        pets,
        babyTrolley,
        specialRequest,
        clubAnnualFee,
      },
      isAddonSearched: true,
      addonAvailabilityError: !result.isSuccess,
      addonSearchResult: result,
    });
  } else {
    return dispatch({
      type: ADDONS_UNAVAILABLE,
      isAddonSearched: true,
      isAddonUnavail: _.isEmpty(data.availableAddons),
      addonAvailabilityError: !result.isSuccess,
      addonSearchResult: result,
    });
  }
};

export const fetchAddons = () => async (
  dispatch: Function,
  getState: Function,
) => {
  dispatch({
    type: SET_IS_FETCHING,
    isFetching: true,
  });
  const { flight, routes, auth } = getState();
  const { selectedOutboundInfo, selectedInboundInfo, selectedIBOBFlight } = flight;
  if (
    selectedIBOBFlight && selectedIBOBFlight.length >= 1
    && (
      (selectedOutboundInfo && selectedOutboundInfo.flightKey)
      || (selectedInboundInfo && selectedInboundInfo.flightKey)
    )) {
    const AdnOBSegData = setAddonSegInfo(selectedOutboundInfo, selectedIBOBFlight);
    const AdnIBSegData = setAddonSegInfo(selectedInboundInfo, selectedIBOBFlight);
    const { searchCriteria } = routes.searchData;
    const { journeyType } = searchCriteria.journeyInfo;
    const { token } = auth;
    if (token && token !== undefined && token !== 'undefined' && token !== '') {
      axios.defaults.headers.common.Authorization = `Bearer ${token}`;
    }

    const res = await execute<IAddonsResponse>(
      'POST',
      'api/addon/search-addons',
      {
        flights:
          (journeyType === 2) ? [
            AdnOBSegData,
            AdnIBSegData,
          ] : [AdnOBSegData],
      },
    );
    const { availableAddons, flightAddon, result } = res.data;
    const addonAvailabilityError: boolean = !result.isSuccess;

    let hasPet = false;
    if (availableAddons) {
      if (!_.isEmpty(availableAddons) && !_.isEmpty(availableAddons.pets)) {
        if (!_.isEmpty(flightAddon)) {
          hasPet = !checkPetPurchase(availableAddons, flightAddon);
        } else {
          hasPet = true;
        }
        dispatch(canPurchasePet(hasPet));
      } else {
        dispatch(canPurchasePet(hasPet));
      }

      const {
        baggage,
        seats,
        meals,
        // flyOnePriority = [],
        largeCabinBag = [],
        priorityNotification = [],
        changeBaggage = [],
        earlyCheckIn = [],
        automatedCheckIn = [],
        airportCheckIn = [],
        tmpBaggage = [],
        changeFlex,
        fareLock,
        baggagePriority,
        baggageGuarantee,
        sportsEquipment,
        addNameLater,
        onTimeGuarantee,
        smsItinerary,
        covid,
        pets,
        babyTrolley,
        specialRequest,
        clubAnnualFee,
      } = availableAddons;
      if (typeof clubAnnualFee !== 'undefined' && !_.isEmpty(clubAnnualFee) && clubAnnualFee.length > 0) {
        const { addOnInfos } = clubAnnualFee[0];
        dispatch({
          type: FETCH_ADDONS_CLUB_DATA,
          isClubAvailable: true,
          addonClubData: addOnInfos,
        });
      }
      dispatch(updateTotalPrice());
      dispatch({
        type: FETCH_ADDONS_SUCCESS,
        isFetching: false,
        availableAddons: {
          seats,
          meals,
          baggage,
          // flyOnePriority,
          largeCabinBag,
          priorityNotification,
          baggagePriority,
          changeBaggage,
          earlyCheckIn,
          baggageGuarantee,
          automatedCheckIn,
          changeFlex,
          fareLock,
          sportsEquipment,
          airportCheckIn,
          addNameLater,
          onTimeGuarantee,
          tmpBaggage,
          smsItinerary,
          covid,
          pets,
          babyTrolley,
          specialRequest,
          clubAnnualFee,
        },
        isAddonSearched: true,
        addonAvailabilityError,
        addonSearchResult: result,
      });
      dispatch({
        type: SET_IS_FETCHING,
        isFetching: false,
      });
    } else {
      dispatch(canPurchasePet(hasPet));
      dispatch({
        type: FETCH_ADDONS_FAILURE,
        isAddonSearched: true,
        addonAvailabilityError,
        addonSearchResult: result,
        isFetching: false,
      });
    }
    return res.data;
  }
  dispatch({
    type: SET_IS_FETCHING,
    isFetching: false,
  });
};

export const setEmptyAddons = (quantity: number) => async (
  dispatch: Function,
) => {
  // const baggages = [];
  const meals = [];
  const fareLock = [];
  const changeFlex = [];
  // const specialRequest = [];
  for (let i = 0; i < quantity; i += 1) {
    meals.push({
      addonKey: '',
      flightKey: '',
      segmentKey: '',
      selectedMeals: [
        {
          paxKey: '',
          meals: [
            {
              mealKey: '',
              qty: 0,
            },
          ],
        },
      ],
    });

    // specialRequest.push({
    //   addonKey: '',
    //   flightKey: '',
    //   segmentKey: '',
    //   selectedSSRAddons: [
    //     {
    //       addonKey: '',
    //       segmentKey: '',
    //       paxKey: '',
    //     },
    //   ],
    // });

    fareLock.push({
      addonKey: '',
      flightKey: '',
      segmentKey: '',
      selectedFareLock: [
        {
          paxKey: '',
          seatNo: '',
          qty: 0,
        },
      ],
    });

    changeFlex.push({
      addonKey: '',
      flightKey: '',
      segmentKey: '',
      selectedChangeFlex: [
        {
          paxKey: '',
          seatNo: '',
          qty: 0,
        },
      ],
    });
  }
  dispatch(updateTotalPrice());
  return dispatch({
    type: SET_EMPTY_ADDONS,
    selectedAddons: {
      baggages: [],
      meals,
      seats: [],
      changeFlex,
      fareLock,
    },
  });
};

export const selectBaggage = (
  isRemove: boolean,
  baggage: any, type: string,
  isOutbound: boolean, baggageAvai: any, paxKey: string, isPreset: boolean, segKey: any,
  quantity?: number, isUpdateQuantity?: boolean,
) => async (
  dispatch: Function,
  getState: Function,
) => {
  const { workflow } = getState();

  if (isRemove) {
    dispatch({
      type: REMOVE_BAGGAGE,
      baggage,
      baggageType: type,
      isOutbound,
      baggageAvai,
      paxKey,
      isPreset,
      quantity,
      isUpdateQuantity,
      isRemove,
      segKey,
    });
    dispatch(updateTotalPrice());
  } else {
    dispatch({
      type: SELECT_BAGGAGE,
      baggage,
      baggageType: type,
      isOutbound,
      baggageAvai,
      paxKey,
      isPreset,
      quantity,
      isUpdateQuantity,
      isRemove,
      segKey,
    });
    dispatch(updateTotalPrice());
  }

  if (workflow && workflow.actionState !== WORKFLOW.SEARCH_FLIGHT) {
    const baggageMenuData = {
      passengerKey: paxKey,
      segmentKey: segKey.segmentKey,
      isAddMore: !isRemove,
      baggageWeight: baggageAvai.weight,
      price: baggageAvai.priceInfo.unitPrice,
      currency: baggageAvai.priceInfo.currency,
      isNewItem: true,
    };
    dispatch(setBaggageMenu(baggageMenuData));
  }
};

export const selectSameBaggage = (
  isOutbound: boolean,
  baggage: any,
  paxKey: string,
  baggageAvai: any,
  segKey: any,
) => async (
  dispatch: Function,
) => {
  dispatch({
    type: SELECT_SAME_BAGGAGE,
    isOutbound,
    baggage,
    paxKey,
    baggageAvai,
    segKey,
  });
  dispatch(selectAllBaggagers());
  dispatch(updateTotalPrice());
};

export const removeAllBaggages = (
  segKey: any, paxKey: string, isSelectSame: boolean,
) => async (
  dispatch: Function,
) => {
  dispatch({
    type: REMOVE_ALL_BAGGAGES,
    segKey,
    paxKey,
    isSelectSame,
  });
  dispatch(updateTotalPrice());
  dispatch(selectAllBaggagers());
};

export const selectBaggageSameForAll = (allPaxArray: string[]) => async (
  dispatch: Function,
) => {
  dispatch({
    type: SELECT_BAGGAGE_ALL,
    allPaxArray,
  });
  dispatch(updateTotalPrice());
  dispatch(selectAllBaggagers());
};

export const initSelectedBaggages = (baggage: any) => (
  dispatch: Function,
) => dispatch({
  type: INIT_BAGGAGES,
  baggage,
});

export const initSelectedSeats = (seats: any) => (
  dispatch: Function, getState: Function,
) => {
  const {
    flight, workflow, mmb, checkin,
  } = getState();
  const { actionState } = workflow;
  const { flightsDoBooking } = checkin;
  const { PNRBookDetails } = mmb;
  const { flightInfo } = PNRBookDetails;
  const { selectedIBOBFlight } = flight;
  const selectedFlightDetail = Array<any>();
  if (
    actionState === WORKFLOW.SEARCH_FLIGHT
      || actionState === WORKFLOW.MMB
  ) {
    selectedIBOBFlight.map((fList: any) => {
      fList.flights.map((sLists: any) => {
        sLists.segments.map((x: any) => {
          selectedFlightDetail.push({
            flightKey: sLists.flightKey,
            segmentKey: x.segmentKey,
            selectedSeats: [],
          });
          return null;
        });
        return null;
      });
      return null;
    });
  } else if (
    (actionState === WORKFLOW.SEAT_MANAGEMENT
  || actionState === WORKFLOW.BAGGAGE_MANAGEMENT
  || actionState === WORKFLOW.SERVICE_MANAGEMENT
  || actionState === WORKFLOW.FARE_LOCK)
  && !_.isEmpty(flightInfo)
  ) {
    flightInfo[0].flights.map((fList: any) => {
      fList.segments.map((sLists: any) => {
        selectedFlightDetail.push({
          flightKey: fList.flightKey,
          segmentKey: sLists.segmentKey,
          selectedSeats: [],
        });
        return null;
      });
      return null;
    });
  } else if (
    actionState === WORKFLOW.CHECK_IN
      && !_.isEmpty(flightsDoBooking)
  ) {
    flightsDoBooking.flights.map((fList: any) => {
      fList.segments.map((sLists: any) => {
        selectedFlightDetail.push({
          flightKey: fList.flightKey,
          segmentKey: sLists.segmentKey,
          selectedSeats: [],
        });
        return null;
      });
      return null;
    });
  }
  dispatch({
    type: INIT_SEATS,
    seats,
    selectedFlightDetail,
  });
};

export const selectSeat = (
  seats: any, addedSeat: any,
  addedSeatFlightKey: string, isOutbound: boolean,
  paxKey: string, segKey: any, isSeatRemoved: boolean,
  rowType: string,
  priceSeatSelected: any, addOnKey: string,
) => async (dispatch: Function,
  getState: Function) => {
  const { workflow } = getState();
  dispatch({
    type: SELECT_SEAT,
    seats,
    addedSeat,
    addedSeatFlightKey,
    isOutbound,
    paxKey,
    segKey,
    isSeatRemoved,
    rowType,
    priceSeatSelected,
    seataddOnKey: addOnKey,
  });
  dispatch(updateTotalPrice());
  if (workflow && workflow.actionState !== WORKFLOW.SEARCH_FLIGHT) {
    const seatMenu = {
      passengerKey: paxKey,
      segmentKey: segKey.segmentKey,
      seatNumber: addedSeat.seatNumber,
      price: paxKey.toLowerCase().indexOf(PAX_TYPE.PAX_TYPE_ADULT.toLowerCase()) >= 0
        ? priceSeatSelected
        : 0,
      currency: addedSeat.priceInfo.currency,
      isSelect: !isSeatRemoved,
      isNewItem: true,
    };
    dispatch(setSeatMenu(seatMenu));
  }
};
export const removeSpecialRequest = (
  selSpclReq: any, isOutbound: boolean, segIndex: number, allSpclReq: any,
  paxKey: string, flightKey: any, SegmentKey: any, serviceType: any,
) => (dispatch: Function,
  getState: Function) => {
  const { workflow } = getState();
  dispatch({
    type: REMOVE_SPCLREQUEST,
    addedSSR: selSpclReq,
    isOutbound,
    segIndex,
    serviceType,
    allSpclReq,
    sSRSegmentKey: SegmentKey,
    paxKey,
    flightKey,
  });
  if (workflow && workflow.actionState !== WORKFLOW.SEARCH_FLIGHT) {
    const serviceMenu = {
      passengerKey: paxKey,
      segmentKey: SegmentKey,
      serviceName: serviceType,
      isSelect: false,
      price: selSpclReq.priceInfo.unitPrice,
    };
    dispatch(setServiceMenu(serviceMenu));
  }
};

export const selectSpecialRequest = (
  selSpclReq: any, isOutbound: boolean, segIndex: number, allSpclReq: any,
  paxKey: string, flightKey: any, SegmentKey: any, serviceType: any,
) => (dispatch: Function,
  getState: Function) => {
  const { workflow } = getState();
  dispatch({
    type: SELECT_SPCLREQUEST,
    addedSSR: selSpclReq,
    spclReqCode: selSpclReq.ssrCode,
    isOutbound,
    segIndex,
    serviceType,
    allSpclReq,
    sSRSegmentKey: SegmentKey,
    paxKey,
    flightKey,
  });

  if (workflow && workflow.actionState !== WORKFLOW.SEARCH_FLIGHT) {
    const displayName = ADDON_SERVICE_DISPLAY_NAME.find(
      (addonName: any) => addonName.name === serviceType,
    );
    if (typeof selSpclReq !== 'undefined') {
      const serviceMenu = {
        passengerKey: paxKey,
        segmentKey: SegmentKey,
        serviceName: serviceType,
        serviceDisplayName: displayName ? displayName.displayName : '',
        price: selSpclReq.priceInfo.unitPrice,
        currency: selSpclReq.priceInfo.currency,
        isSelect: true,
        isNewItem: true,
        type: selSpclReq.ssrCode,
      };
      dispatch(setServiceMenu(serviceMenu));
    }
  }
};

export const selectMeal = (
  meal: any, isOutbound: boolean, segIndex: number, meals: any, paxKey: string, flightKey: any,
) => (dispatch: Function,
  getState: Function) => {
  const { workflow } = getState();

  dispatch({
    type: SELECT_MEAL,
    addedMeal: meal,
    isOutbound,
    segIndex,
    meals,
    paxKey,
    flightKey,
  });
  dispatch(updateTotalPrice());
  if (workflow && workflow.actionState !== WORKFLOW.SEARCH_FLIGHT) {
    const displayName = ADDON_SERVICE_DISPLAY_NAME.find(
      (addonName: any) => addonName.name === ADDON_NAME.MEALS,
    );
    const serviceMenu = {
      passengerKey: paxKey,
      segmentKey: meals[segIndex].segmentKey,
      serviceName: ADDON_NAME.MEALS,
      serviceDisplayName: displayName ? displayName.displayName : '',
      type: meal.ssrCode,
      price: meal.priceInfo.unitPrice,
      currency: meal.priceInfo.currency,
      isSelect: true,
      isNewItem: true,
    };
    dispatch(setServiceMenu(serviceMenu));
  }
};

export const removeMeal = (
  meal: any, isOutbound: boolean, segIndex: number, meals: any, paxKey: string, flightKey: any,
) => (dispatch: Function,
  getState: Function) => {
  const { workflow } = getState();
  dispatch({
    type: REMOVE_MEAL,
    addedMeal: meal,
    isOutbound,
    segIndex,
    meals,
    paxKey,
    flightKey,
  });
  dispatch(updateTotalPrice());

  if (workflow && workflow.actionState !== WORKFLOW.SEARCH_FLIGHT) {
    const serviceMenu = {
      passengerKey: paxKey,
      segmentKey: meals[segIndex].segmentKey,
      serviceName: ADDON_NAME.MEALS,
      isSelect: false,
      price: !_.isEmpty(meals[segIndex].priceInfo) ? meals[segIndex].priceInfo.unitPrice : 0,
    };
    dispatch(setServiceMenu(serviceMenu));
  }
};

export const selectSMSService = (
  service: any,
  serviceName:any,
  serviceType: any,
) => (dispatch: Function) => {
  dispatch({
    type: SELECT_SMS_SERVICE,
    service,
    serviceName,
    serviceType,
  });
  dispatch(updateTotalPrice());
};

export const selectService = (
  service: any,
  serviceName: string,
  serviceType: string,
  flightKey: string,
  isOutbound: boolean = true,
  paxKey?: string,
) => async (dispatch: Function,
  getState: Function) => {
  const { workflow } = getState();
  dispatch({
    type: SELECT_SERVICE,
    service,
    serviceName,
    serviceType,
    flightKey,
    isOutbound,
    paxKey,
  });
  dispatch(updateTotalPrice());
  if (workflow && workflow.actionState !== WORKFLOW.SEARCH_FLIGHT) {
    const displayName = ADDON_SERVICE_DISPLAY_NAME.find(
      (addonName: any) => addonName.name === serviceType,
    );
    if (typeof service !== 'undefined') {
      const serviceMenu = {
        passengerKey: paxKey,
        segmentKey: service.segmentKey,
        serviceName: serviceType,
        serviceDisplayName: displayName ? displayName.displayName : '',
        price: service.priceInfo.unitPrice,
        currency: service.priceInfo.currency,
        isSelect: true,
        isNewItem: true,
      };
      dispatch(setServiceMenu(serviceMenu));
    }
  }
};

export const deSelectService = (
  serviceType: string,
  price: any,
) => (dispatch: Function,
  getState: Function) => {
  const { workflow } = getState();
  dispatch({
    type: DESELECT_SERVICE,
    serviceType,
  });
  dispatch(updateTotalPrice());
  if (workflow && workflow.actionState !== WORKFLOW.SEARCH_FLIGHT) {
    const serviceMenu = {
      serviceName: serviceType,
      price,
    };
    dispatch(deSelectServiceMenu(serviceMenu));
  }
};

export const removeService = (
  serviceType: string,
  isOutbound: boolean = true,
  paxKey?: string,
) => (dispatch: Function) => {
  dispatch({
    type: REMOVE_SERVICE,
    serviceType,
    isOutbound,
    paxKey,
  });
  dispatch(updateTotalPrice());
};

export const removeServiceBySegment = (
  serviceType: string,
  segmentKey: string,
  unitPrice: any,
  paxKey?: string,
) => async (dispatch: Function,
  getState: Function) => {
  const { workflow } = getState();
  dispatch({
    type: DESELECT_SERVICE_BY_SEGMENT,
    serviceType,
    segmentKey,
    paxKey,
  });
  dispatch(updateTotalPrice());

  if (workflow && workflow.actionState !== WORKFLOW.SEARCH_FLIGHT) {
    const serviceMenu = {
      passengerKey: paxKey,
      segmentKey,
      serviceName: serviceType,
      isSelect: false,
      price: unitPrice,
    };
    dispatch(setServiceMenu(serviceMenu));
  }
};

export const parseBaggage = (state: any) => {
  const { baggages } = state.addon.selectedAddons;

  const data: any = [];
  baggages.forEach((bag: any) => {
    if (bag.segmentKey) {
      const { addonKey, flightKey, segmentKey } = bag;
      // eslint-disable-next-line prefer-const
      let selectedbags: any = [];
      if (bag.selectedBags && bag.selectedBags.length > 0) {
        bag.selectedBags.forEach((selected: any) => {
          if (selected.baggage && selected.baggage.length > 0 && !_.isEmpty(selected.baggage)) {
            const { paxKey } = selected;
            // eslint-disable-next-line no-shadow
            const baggages: any = [];
            selected.baggage.forEach((baggage: any) => {
              const { baggageKey, quantity } = baggage;
              // if (baggage.price !== 0) {
              baggages.push({
                BaggageKey: baggageKey,
                qty: quantity,
              });
              // }
            });
            selectedbags.push({
              paxKey, baggage: baggages,
            });
          }
        });
        if (selectedbags.length > 0) {
          data.push({
            addonKey,
            flightKey,
            segmentkey: segmentKey,
            selectedbags,
          });
        }
      }
    }
  });
  return data;
};

export const parseMeals = (state: any) => {
  const { meals } = state.addon.selectedAddons;

  const data: any = [];
  meals.forEach((mItem: any) => {
    if (mItem.segmentKey) {
      const { addonKey, flightKey, segmentKey } = mItem;
      // eslint-disable-next-line prefer-const
      let selectedMeal: any = [];
      if (mItem.selectedMeals && mItem.selectedMeals.length > 0) {
        const slectedMeals: any = _.groupBy(mItem.selectedMeals, 'paxKey');
        _.map(slectedMeals, (selected: any, key: any) => {
          const mealsData: any = [];
          if (key) {
            selected.map((meal: any) => {
              const { mealKey, quantity } = meal;
              mealsData.push({
                mealKey,
                qty: quantity,
              });
              return false;
            });
            selectedMeal.push({
              paxKey: key, meals: mealsData,
            });
          }
        });
        if (selectedMeal.length > 0) {
          data.push({
            addonKey,
            flightKey,
            segmentkey: segmentKey,
            selectedMeals: selectedMeal,
          });
        }
      }
    }
  });
  return data;
};
export const parseSeats = (state: any) => {
  const { seats } = state.addon.selectedAddons;
  const data: any = [];
  seats.forEach((sItem: any) => {
    if (sItem.segmentKey) {
      if (sItem.selectedSeats && sItem.selectedSeats.length > 0) {
        const { addonKey, flightKey, segmentKey } = sItem;
        // eslint-disable-next-line prefer-const
        let seltedSeats: any = [];
        if (sItem.selectedSeats) {
          _.map(sItem.selectedSeats, (selected: any) => {
            const { paxKey, seatNo, quantity } = selected;
            if (seatNo !== '') {
              seltedSeats.push({
                paxKey, seatNo, qty: quantity,
              });
            }
          });
        }
        if (seltedSeats.length > 0) {
          data.push({
            addonKey,
            flightKey,
            segmentkey: segmentKey,
            selectedSeats: seltedSeats,
          });
        }
      }
    }
  });
  return data;
};

export const parseBaggageAddons = (baggagePageAddon: any) => {
  const data: any = [];

  baggagePageAddon.forEach((sItem: any) => {
    const {
      addonKey,
      flightKey,
      segmentKey,
      paxKey,
      paxIndex,
      price,
      currency,
      ssrName,
      name,
    } = sItem;
    if (!_.isEmpty(paxKey)) {
      data.push({
        addonKey,
        flightKey,
        segmentKey,
        paxKey,
        paxIndex: !_.isEmpty(paxIndex) ? paxIndex : 0,
        price,
        currency,
        ssrName,
        name,
      });
    }
  });
  return data;
};

export const selectAddons = () => async (dispatch: Function, getState: Function) => {
  const { selectedAddons } = getState().addon;
  const { paxInfoDetails } = getState().payment;
  const {
    // flyOnePriority,
     largeCabinBag, priorityNotification, baggagePriority,
    changeFlex, airportCheckIn, sportsEquipment, onTimeGuarantee,
    changeBaggage, earlyCheckIn, baggageGuarantee, automatedCheckIn,
    addNameLater, fareLock, smsItinerary, covid, pets, babyTrolley,
    specialRequest,
  } = selectedAddons;
  const flatAirpot = _.flattenDeep(airportCheckIn);
  const flatErlyChk = _.flattenDeep(earlyCheckIn);

  const { baggages } = selectedAddons;
  const {
    flight, routes, totalAmount, auth,
  } = getState();
  const { selectedOutboundInfo, selectedInboundInfo, clubSelected } = flight;
  const { discountInfo, token } = auth;
  const { searchCriteria } = routes.searchData;
  const { paxInfo, journeyInfo } = searchCriteria;
  const { journeyType } = journeyInfo;
  const DeptCabin = selectedOutboundInfo.cabinClass;
  const RetnCabin = selectedInboundInfo.cabinClass;
  const isChangeFlexSent = journeyType === 2 ? (DeptCabin === 'AD' && RetnCabin === 'AD') : DeptCabin === 'AD';

  let CabinCode = 'ST';
  const trvlBaggAry: any[] = [];

  _.map(baggages, (fligList: any) => {
    let curFlgtData: any;
    if (selectedOutboundInfo.flightKey === fligList.flightKey) {
      curFlgtData = selectedOutboundInfo;
    } else if (selectedInboundInfo.flightKey === fligList.flightKey) {
      curFlgtData = selectedInboundInfo;
    }
    CabinCode = curFlgtData.cabinClass;
    const RouteCode = fligList.segmentKey.split('_');
    const DeptCode = RouteCode[1].substring(0, 3);
    const ArvlCode = RouteCode[1].substring(3, 6);
    _.map(paxInfo, (paxList: any) => {
      const getPaxInfo = _.filter(paxInfoDetails, (
        pxLst: any,
      ) => pxLst.passengerKey === paxList.paxKey);
      if (CabinCode === 'AD' || CabinCode === 'LO') {
        trvlBaggAry.push({
          first_name: getPaxInfo.length > 0 ? getPaxInfo[0].firstName : '',
          last_name: getPaxInfo.length > 0 ? getPaxInfo[0].lastName : '',
          type: 'Free',
          weight: '20',
          price: '0',
          currency: totalAmount.currencyCode,
          origin: DeptCode,
          destination: ArvlCode,
        });
      }
      if (CabinCode === 'AD') {
        trvlBaggAry.push({
          first_name: getPaxInfo.length > 0 ? getPaxInfo[0].firstName : '',
          last_name: getPaxInfo.length > 0 ? getPaxInfo[0].lastName : '',
          type: 'Free',
          weight: '10',
          price: '0',
          currency: '',
          origin: DeptCode,
          destination: ArvlCode,
        });
      }
      const { selectedBags } = fligList;
      _.map(selectedBags, (paxListt: any) => {
        const { baggage } = paxListt;
        const getaPaxInfo = _.filter(paxInfoDetails, (
          pxLst: any,
        ) => pxLst.passengerKey === paxListt.paxKey);
        _.map(baggage, (bagList: any) => {
          trvlBaggAry.push({
            first_name: getaPaxInfo.length > 0 ? getaPaxInfo[0].firstName : '',
            last_name: getaPaxInfo.length > 0 ? getaPaxInfo[0].lastName : '',
            type: bagList.type,
            weight: bagList.weight,
            price: bagList.price,
            currency: bagList.currency,
            origin: DeptCode,
            destination: ArvlCode,
          });
        });
      });
    });
  });

  const travlytixBaggageData = {
    baggage: trvlBaggAry,
  };
  let smsService: any = [];
  if (!_.isEmpty(smsItinerary)) {
    smsService = [
      {
        addOnKey: smsItinerary[0].addonKey,
      },
    ];
  }
  const SpecialReqAddon: any[] = [];

  if (!_.isEmpty(specialRequest)) {
    _.map(specialRequest, (srList: any) => {
      return _.map(srList.selectedSSRAddons, (segSRItm: any) => {
        SpecialReqAddon.push({
          addonKey: [segSRItm.addonKey],
          flightKey: segSRItm.flightKey,
          segmentKey: segSRItm.segmentKey,
          paxKey: segSRItm.paxKey,
        });
      });
    });
  }
  let addonKey: string = '';
  let clubAnnualFeeData: any[] = [];
  let isAmountPaid: boolean = false;
  if (!_.isEmpty(discountInfo)) {
    ({ addonKey, isAmountPaid } = discountInfo);
    clubAnnualFeeData = clubSelected && !isAmountPaid && !_.isEmpty(addonKey)
      ? ([
        {
          AddOnKey: addonKey,
        },
      ])
      : [];
  }
  if (token && token !== undefined && token !== 'undefined' && token !== '') {
    axios.defaults.headers.common.Authorization = `Bearer ${token}`;
  }
  const res = await execute<ISelectdAddonsResponse>(
    'POST',
    'api/addon/select-addons',
    {
      addOnSelections: {
        changeFlex: isChangeFlexSent ? [] : changeFlex,
        sportsEquipment,
        baggages: parseBaggage(getState()),
        meals: parseMeals(getState()),
        seats: parseSeats(getState()),
        // flyOnePriority: parseBaggageAddons(flyOnePriority),
        largeCabinBag: parseBaggageAddons(largeCabinBag),
        priorityNotification,
        baggagePriority: parseBaggageAddons(baggagePriority),
        changeBaggage,
        earlyCheckIn: flatErlyChk,
        airportCheckIn: flatAirpot,
        baggageGuarantee: parseBaggageAddons(baggageGuarantee),
        automatedCheckIn,
        addNameLater,
        onTimeGuarantee,
        fareLock,
        covid,
        pets,
        babyTrolley: parseBaggageAddons(babyTrolley),
        smsItinerary: smsService,
        specialRequest: SpecialReqAddon,
        clubAnnualFee: clubAnnualFeeData,
      },
    },
  );
  const { result } = res.data;
  let canProceed: boolean = false;
  if (result.isSuccess) {
    canProceed = result.isSuccess;
  } else {
    const [error] = res.data.result.msgs;
    canProceed = error.msgText === 'NoSelectionMade';
  }

  const { seats } = selectedAddons;
  const trvlSeatAry: any[] = [];
  _.map(seats, (fligList: any) => {
    const RouteCode = fligList.segmentKey.split('_');
    const DeptCode = RouteCode[1].substring(0, 3);
    const ArvlCode = RouteCode[1].substring(3, 6);
    const { selectedSeats } = fligList;
    _.map(selectedSeats, (seatlist: any) => {
      trvlSeatAry.push({
        first_name: seatlist.paxKey.toLowerCase(),
        last_name: seatlist.paxKey.toLowerCase(),
        type: seatlist.rowType,
        seat_number: seatlist.seatNo,
        price: seatlist.price,
        currency: seatlist.currency,
        origin: DeptCode,
        destination: ArvlCode,
      });
    });
  });

  const travlytixSeatData = {
    seats: trvlSeatAry,
  };
  const mealsData: any[] = [];
  if (selectedAddons.meals && selectedAddons.meals.length > 0) {
    selectedAddons.meals.forEach((meal: any) => {
      if (meal.addonKey !== undefined && meal.addonKey !== '') {
        const arrs = meal.addonKey.split('_');
        meal.selectedMeals.forEach((m: any) => {
          mealsData.push({
            first_name: m.paxKey.toLowerCase(),
            last_name: m.paxKey.toLowerCase(),
            name: m.mealKey,
            price: m.price,
            currency: m.currency,
            origin: arrs[1],
            destination: arrs[2],
          });
        });
      }
    });
  }

  const travlytixMeal = {
    meals: mealsData,
  };

  const ancillaries: any[] = [];

  if (selectedAddons.airportCheckIn && selectedAddons.airportCheckIn.length > 0) {
    selectedAddons.airportCheckIn.forEach((item: any) => {
      if (item.addonKey !== undefined && item.addonKey !== '') {
        const arrs = item.addonKey.split('_');
        ancillaries.push({
          first_name: item.paxKey.toLowerCase(),
          last_name: item.paxKey.toLowerCase(),
          type: 'Airport checkin',
          name: item.name,
          price: item.price,
          currency: item.currency,
          origin: arrs[1],
          destination: arrs[2],
        });
      }
    });
  }

  if (selectedAddons.earlyCheckIn && selectedAddons.earlyCheckIn.length > 0) {
    selectedAddons.earlyCheckIn.forEach((item: any) => {
      if (item.addonKey !== undefined && item.addonKey !== '') {
        const arrs = item.addonKey.split('_');
        ancillaries.push({
          first_name: item.paxKey,
          last_name: item.paxKey,
          type: 'Early checkin',
          name: item.name,
          price: item.price,
          currency: item.currency,
          origin: arrs[1],
          destination: arrs[2],
        });
      }
    });
  }

  if (selectedAddons.sportsEquipment && selectedAddons.sportsEquipment.length > 0) {
    selectedAddons.sportsEquipment.forEach((item: any) => {
      if (item.addonKey !== undefined && item.addonKey !== '') {
        const arrs = item.addonKey.split('_');
        ancillaries.push({
          first_name: item.paxKey,
          last_name: item.paxKey,
          type: 'Sports Equipment',
          name: item.name,
          price: item.price,
          currency: item.currency,
          origin: arrs[1],
          destination: arrs[2],
        });
      }
    });
  }

  if (selectedAddons.priorityNotification && selectedAddons.priorityNotification.length > 0) {
    selectedAddons.priorityNotification.forEach((item: any) => {
      if (item.addonKey !== undefined && item.addonKey !== '') {
        const arrs = item.addonKey.split('_');
        ancillaries.push({
          first_name: item.paxKey,
          last_name: item.paxKey,
          type: 'Priority Notification',
          name: item.name,
          price: item.price,
          currency: item.currency,
          origin: arrs[1],
          destination: arrs[2],
        });
      }
    });
  }

  if (selectedAddons.automatedCheckIn && selectedAddons.automatedCheckIn.length > 0) {
    selectedAddons.automatedCheckIn.forEach((item: any) => {
      if (item.addonKey !== undefined && item.addonKey !== '') {
        const arrs = item.addonKey.split('_');
        ancillaries.push({
          first_name: item.paxKey,
          last_name: item.paxKey,
          type: 'Automated',
          name: item.name,
          price: item.price,
          currency: item.currency,
          origin: arrs[1],
          destination: arrs[2],
        });
      }
    });
  }

  const ancillariesData = {
    ancillaries,
  };

  if (process.browser && res && typeof window.Travlytix !== 'undefined') {
    if (travlytixMeal.meals.length > 0) {
      window.Travlytix.Flight.Meals(travlytixMeal);
      window.Travlytix.Send();
    }

    if (travlytixSeatData.seats.length > 0) {
      window.Travlytix.Flight.Seats(travlytixSeatData);
      window.Travlytix.Send();
    }

    if (travlytixBaggageData.baggage.length > 0 && travlytixBaggageData.baggage[0].first_name !== '') {
      window.Travlytix.Flight.Baggage(travlytixBaggageData);
      window.Travlytix.Send();
    }

    if (ancillariesData.ancillaries.length > 0) {
      window.Travlytix.Flight.Ancillaries(ancillariesData);
      window.Travlytix.Send();
    }
  }

  dispatch(updateAuth());
  dispatch(updateTotalPrice());
  dispatch({
    type: SELECT_ADDONS_SUCCESS,
    selectedAddons: res,
    selAddonResult: res.data.result,
    canProceed,
  });


  return {
    selAddonResult: res.data.result,
    canProceed,
  };
};

export const selectAddonClub = (
  clubInfo: any, serviceName: any, serviceType: any,
) => async (dispatch: Function) => {
  dispatch({
    type: SELECT_ADDONS_CLUB,
    // selectedClub: clubInfo,
    service: clubInfo,
    serviceName,
    serviceType,
  });
};

export const getAddonSelectionStatus = () => async (getState: Function) => {
  const { addon } = getState();
  const { selAddonResult, canProceed } = addon;
  return {
    selAddonResult,
    canProceed,
  };
};

export const setAddonBaggagePageSameBothWays = (
  pax: any, currentFlightKey: any,
) => async (dispatch: Function, getState: Function) => {
  const { addon, flight, checkin } = getState();

  const { flightsDetail } = flight;

  const anotherFlights = flightsDetail.filter((x: any) => x.flightKey !== currentFlightKey);

  function setupBaggage() {
    const {
      baggage,
    } = addon.availableAddons;

    const allBaggage = addon.selectedAddons.baggages;

    const allBaggageSelectedOnSegment = allBaggage.find(
      (x: any) => x.flightKey === currentFlightKey,
    );

    const allBaggageSelectedOnSegmentByPax = allBaggageSelectedOnSegment.selectedBags.find(
      (x: any) => x.paxKey === pax,
    );

    const newAllBaggage = allBaggage.filter((x: any) => x.flightKey === currentFlightKey);

    for (let i = 0; i < anotherFlights.length; i += 1) {
      const anotherFlight = anotherFlights[i];
      const segmentBag = allBaggage.find((x: any) => x.flightKey === anotherFlight.flightKey);

      if (segmentBag.selectedBags.length > 0) {
        segmentBag.selectedBags = segmentBag.selectedBags.filter((x: any) => x.paxKey !== pax);
      }

      let tenIndex = 0;
      let twentyIndex = 0;
      let thirtyIndex = 0;
      let baggageAddon = null;

      for (let j = 0; j < baggage.length; j += 1) {
        const bag = baggage[j];
        if (bag.segmentKeyRef.find((x: any) => x === anotherFlight.segmentKey)) {
          baggageAddon = bag.availability.baggageInfo[0] as any;
        }
      }

      if (baggageAddon) {
        const newBaggage = [];
        const baggageOfMainSegment = allBaggageSelectedOnSegmentByPax
        && allBaggageSelectedOnSegmentByPax.baggage ? allBaggageSelectedOnSegmentByPax.baggage : [];
        let addonKey = '';
        for (let j = 0; j < baggageOfMainSegment.length; j += 1) {
          let thisIndex = 0;
          const bag = baggageOfMainSegment[j];

          if (bag.weight === 10) {
            tenIndex += 1;
            thisIndex = tenIndex - 1;
          }

          if (bag.weight === 20) {
            twentyIndex += 1;
            thisIndex = twentyIndex - 1;
          }

          if (bag.weight === 30) {
            thirtyIndex += 1;
            thisIndex = thirtyIndex - 1;
          }

          const baggageSize = baggageAddon.weight.filter(
            (x: any) => x.weight === bag.weight,
          )[thisIndex];

          if (baggageSize) {
            addonKey = baggageSize.baggageKey;
            newBaggage.push({
              baggageKey: baggageSize.baggageKey,
              currency: baggageSize.priceInfo.currency,
              price: baggageSize.priceInfo.unitPrice,
              quantity: 1,
              type: 'CI',
              weight: baggageSize.weight,
            });
          }
        }
        segmentBag.addonKey = addonKey;
        if (!_.isEmpty(newBaggage)) {
          segmentBag.selectedBags.push({
            paxKey: pax,
            baggage: newBaggage,
          });
        }
        newAllBaggage.push(segmentBag);
      }
    }

    return newAllBaggage;
  }
  const {
    // flyOnePriority, 
    baggagePriority,
    baggageGuarantee, babyTrolley, largeCabinBag,
  } = addon.selectedAddons;
  addon.selectedAddons.baggages = setupBaggage();
  addon.selectedAddons.baggageGuarantee = _.isEmpty(baggageGuarantee)
    ? [] : setupBaggageGuarantee(addon, currentFlightKey, pax, anotherFlights);
  const { cabinSettings } = checkin;
  // if (journeyHasAdvantageCbinClass(cabinSettings)) {
  //   addon.selectedAddons.flyOnePriority = _.isEmpty(flyOnePriority)
  //     ? [] : setupFlyOnePriority(addon, currentFlightKey, pax, anotherFlights);
  // }
  if (journeyHasAdvantageCbinClass(cabinSettings)) {
    addon.selectedAddons.largeCabinBag = _.isEmpty(largeCabinBag)
      ? [] : setuplargeCabinBag(addon, currentFlightKey, pax, anotherFlights);
  }
  addon.selectedAddons.baggagePriority = _.isEmpty(baggagePriority)
    ? [] : setupBaggagePriority(addon, currentFlightKey, pax, anotherFlights);
  addon.selectedAddons.babyTrolley = _.isEmpty(babyTrolley)
    ? [] : setupBabyTrolley(addon, currentFlightKey, pax, anotherFlights);

  const selectedAddons = addon.selectedAddons as any;

  dispatch(updateBaggagePageAddonsForBothways(selectedAddons));
};

export const setBaggageGuaranteeBothWays = (
  pax: any, currentFlightKey: any,
) => async (dispatch: Function, getState: Function) => {
  const { addon, flight } = getState();

  const { flightsDetail } = flight;

  const anotherFlights = flightsDetail.filter((x: any) => x.flightKey !== currentFlightKey);

  addon.selectedAddons.baggageGuarantee = setupBaggageGuarantee(
    addon, currentFlightKey, pax, anotherFlights,
  );

  const selectedAddons = addon.selectedAddons as any;

  dispatch(updateBaggagePageAddonsForBothways(selectedAddons));
};

// export const setFlyOnePrioritySameBothWays = (
//   pax: any, currentFlightKey: any,
// ) => async (dispatch: Function, getState: Function) => {
//   const { addon, flight, checkin } = getState();

//   const { flightsDetail } = flight;

//   const anotherFlights = flightsDetail.filter((x: any) => x.flightKey !== currentFlightKey);

//   const { cabinSettings } = checkin;
//   if (journeyHasAdvantageCbinClass(cabinSettings)) {
//     addon.selectedAddons.flyOnePriority = setupFlyOnePriority(
//       addon, currentFlightKey, pax, anotherFlights,
//     );
//   }
//   const selectedAddons = addon.selectedAddons as any;

//   dispatch(updateBaggagePageAddonsForBothways(selectedAddons));
// };

export const setlargeCabinBagSameBothWays = (
  pax: any, currentFlightKey: any,
) => async (dispatch: Function, getState: Function) => {
  const { addon, flight, checkin } = getState();

  const { flightsDetail } = flight;

  const anotherFlights = flightsDetail.filter((x: any) => x.flightKey !== currentFlightKey);

  const { cabinSettings } = checkin;
  if (journeyHasAdvantageCbinClass(cabinSettings)) {
    addon.selectedAddons.largeCabinBag = setuplargeCabinBag(
      addon, currentFlightKey, pax, anotherFlights,
    );
  }
  const selectedAddons = addon.selectedAddons as any;

  dispatch(updateBaggagePageAddonsForBothways(selectedAddons));
};


export const setBaggagePrioritySameBothWays = (
  pax: any, currentFlightKey: any,
) => async (dispatch: Function, getState: Function) => {
  const { addon, flight } = getState();

  const { flightsDetail } = flight;

  const anotherFlights = flightsDetail.filter((x: any) => x.flightKey !== currentFlightKey);

  addon.selectedAddons.baggagePriority = setupBaggagePriority(
    addon, currentFlightKey, pax, anotherFlights,
  );

  const selectedAddons = addon.selectedAddons as any;

  dispatch(updateBaggagePageAddonsForBothways(selectedAddons));
};

export const setBabyTrolleySameBothWays = (
  pax: any, currentFlightKey: any,
) => async (dispatch: Function, getState: Function) => {
  const { addon, flight } = getState();

  const { flightsDetail } = flight;

  const anotherFlights = flightsDetail.filter((x: any) => x.flightKey !== currentFlightKey);

  addon.selectedAddons.babyTrolley = setupBabyTrolley(
    addon, currentFlightKey, pax, anotherFlights,
  );

  const selectedAddons = addon.selectedAddons as any;

  dispatch(updateBaggagePageAddonsForBothways(selectedAddons));
};

export const removeBaggageGuaranteeBothWays = (pax: any) => async (
  dispatch: Function, getState: Function,
) => {
  const { addon } = getState();
  addon.selectedAddons.baggageGuarantee = _.filter(
    addon.selectedAddons.baggageGuarantee,
    fp => fp.paxKey !== pax,
  );
  const selectedAddons = addon.selectedAddons as any;

  dispatch(updateBaggagePageAddonsForBothways(selectedAddons));
};

// export const removeFlyOnePrioritySameBothWays = (pax: any) => async (
//   dispatch: Function, getState: Function,
// ) => {
//   const { addon } = getState();
//   addon.selectedAddons.flyOnePriority = _.filter(
//     addon.selectedAddons.flyOnePriority,
//     fp => fp.paxKey !== pax,
//   );
//   const selectedAddons = addon.selectedAddons as any;

//   dispatch(updateBaggagePageAddonsForBothways(selectedAddons));
// };

export const removelargeCabinBagSameBothWays = (pax: any) => async (
  dispatch: Function, getState: Function,
) => {
  const { addon } = getState();
  addon.selectedAddons.largeCabinBag = _.filter(
    addon.selectedAddons.largeCabinBag,
    fp => fp.paxKey !== pax,
  );
  const selectedAddons = addon.selectedAddons as any;

  dispatch(updateBaggagePageAddonsForBothways(selectedAddons));
};

export const removeBaggagePrioritySameBothWays = (pax: any) => async (
  dispatch: Function, getState: Function,
) => {
  const { addon } = getState();
  addon.selectedAddons.baggagePriority = _.filter(
    addon.selectedAddons.baggagePriority,
    fp => fp.paxKey !== pax,
  );
  const selectedAddons = addon.selectedAddons as any;

  dispatch(updateBaggagePageAddonsForBothways(selectedAddons));
};

export const removeBabyTrolleySameBothWays = (pax: any) => async (
  dispatch: Function, getState: Function,
) => {
  const { addon } = getState();
  addon.selectedAddons.babyTrolley = _.filter(
    addon.selectedAddons.babyTrolley,
    fp => fp.paxKey !== pax,
  );
  const selectedAddons = addon.selectedAddons as any;

  dispatch(updateBaggagePageAddonsForBothways(selectedAddons));
};

// REDUCER
export const AddonReducer = (
  state = AddontInitState,
  action: {
    type: string,
    availableAddons: IAddon[] | any,
    updateAddons: any,
    totalAddonsPrice: any,
    selectedAddons: {
      seats: any;
      meals: any;
      baggage: any;
      // flyOnePriority: any;
      largeCabinBag: any
      priorityNotification: any;
      baggagePriority: any;
      changeBaggage: any;
      earlyCheckIn: any;
      baggageGuarante: any;
      automatedCheckIn: any;
      addNameLater: any;
      tmpBaggage: any;
      specialRequest: any;
      covid: any;
    },
    isFetching: boolean,
    baggage: any,
    segIndex: number,
    key: number,
    isOutbound: boolean,
    baggageType: string;
    baggageAvai: any;
    paxKey: string;
    isPreset: boolean;
    isAddonSearched: boolean;
    seats: any;
    removedSeat: any;
    addedSeat: any;
    addedSeatFlightKey: string;
    meals: any;
    allSpclReq: any;
    addedMeal: any;
    removedMeal: any;
    addedSSR: any;
    spclReqCode: any;
    service: any;
    serviceType: string;
    serviceName: string;
    flightKey: string;
    newState: any;
    quantity: number;
    isUpdateQuantity: boolean;
    isSelectSame: boolean,
    isRemove: boolean,
    seatSegmentKey: string;
    segKey: any,
    toDo: boolean,
    isSeatRemoved: boolean,
    allPaxArray: string[],
    segmentKey: string,
    sSRSegmentKey: string,
    rowType: string,
    selAddonResult: any,
    canProceed: boolean,
    priceSeatSelected: any,
    seataddOnKey: string,
    addonAvailabilityError: boolean,
    addonSearchResult: any,
    canPurchasePet: boolean,
    isAddonUnavail: boolean,
    sameForBothBaggagePaxSettings: any,
    bothPaxSettingsDone: boolean,
    selectedFlightDetail: [],
    isClubAvailable: boolean,
    addonClubData: [],
    // selectedClub: any,
  },
) => {
  const selectedAddons = _.cloneDeep(state.selectedAddons);
  const totalAddonsPrice = _.cloneDeep(state.totalAddonsPrice);
  const updatedSelectedAddons = _.cloneDeep(selectedAddons);
  const updatedSelectedAddons2 = _.cloneDeep(selectedAddons);
  const uppdatedTotalAddonsPrice = _.cloneDeep(totalAddonsPrice);
  let paxIndex: number;

  let selectedBags: any[] = [];

  let sIndex = -1;

  if (updatedSelectedAddons.baggages
    && updatedSelectedAddons.baggages.length >= 1 && action.segKey) {
    updatedSelectedAddons.baggages.forEach((b: any, index: number) => {
      if (b.flightKey === action.segKey.flightKey
        && b.segmentKey === action.segKey.segmentKey) sIndex = index;
    });
  }
  if (sIndex !== -1) {
    selectedBags = [
      ...(updatedSelectedAddons.baggages[sIndex] as any).selectedBags,
    ];
  }

  switch (action.type) {
    case FETCHING_ADDONS:
      return {
        ...state,
        isFetching: action.isFetching,
      };
    case SET_PET_PURCHASED:
      return {
        ...state,
        canPurchasePet: action.canPurchasePet,
      };
    case RESET_SELECTED_ADDONS:
      return {
        ...state,
        selectedAddons: action.newState.selectedAddons,
        totalAddonsPrice: action.newState.totalAddonsPrice,
        isAddonSearched: false,
      };
    case FETCH_ADDONS_FAILURE:
      return {
        ...state,
        isAddonSearched: action.isAddonSearched,
        addonAvailabilityError: action.addonAvailabilityError,
        addonSearchResult: action.addonSearchResult,
      };
    case FETCH_ADDONS_SUCCESS:
      return {
        ...state,
        availableAddons: action.availableAddons,
        isAddonSearched: action.isAddonSearched,
        addonAvailabilityError: action.addonAvailabilityError,
        addonSearchResult: action.addonSearchResult,
      };
    case FETCH_ADDONS_CLUB_DATA:
      return {
        ...state,
        isClubAvailable: action.isClubAvailable,
        addonClubData: action.addonClubData,
      };
    case UPDATE_ADDONS_SUCCESS:
      return {
        ...state,
        updateAddons: action.updateAddons,
      };
    case SELECT_ADDONS_SUCCESS:
      return {
        ...state,
        selAddonResult: action.selAddonResult,
        canProceed: action.canProceed,
        // selectedAddons: action.selectedAddons,
      };
    case REMOVE_BAGGAGE:

      const key = action.baggageAvai.baggageKey;
      paxIndex = -1;
      selectedBags.forEach((b: any, index: number) => {
        if (b.paxKey === action.paxKey) paxIndex = index;
      });
      if (paxIndex !== -1) {
        selectedBags[paxIndex].baggage = _.filter(selectedBags[paxIndex].baggage, (
          b: any,
        ) => b.baggageKey !== key);
      }

      // (updatedSelectedAddons.baggages[sIndex] as any) = {
      //   addonKey: action.baggageAvai.baggageKey || '',
      //   flightKey: action.baggage[sIndex].flightKey || '',
      //   segmentKey: action.baggage[sIndex].segmentKey || '',
      //   selectedBags: [...selectedBags],
      // };

      uppdatedTotalAddonsPrice.baggages.price = 0;
      updatedSelectedAddons.baggages.forEach((a: any) => {
        if (a.selectedBags && a.selectedBags.length >= 1) {
          a.selectedBags.forEach((b: any) => {
            if (b.baggage && b.baggage.length >= 1) {
              b.baggage.forEach((c: any) => {
                uppdatedTotalAddonsPrice.baggages.price += c.price;
                if (c.currency !== uppdatedTotalAddonsPrice.baggages.currency) {
                  uppdatedTotalAddonsPrice.baggages.currency = c.currency;
                }
              });
            }
          });
        }
      });
      return {
        ...state,
        selectedAddons: _.cloneDeep(updatedSelectedAddons),
        totalAddonsPrice: uppdatedTotalAddonsPrice,
      };
    case INIT_BAGGAGES:
      if (updatedSelectedAddons.baggages && updatedSelectedAddons.baggages.length < 4) {
        action.baggage.forEach((b: any) => {
          (updatedSelectedAddons.baggages as any).push({
            flightKey: b.flightKey,
            segmentKey: b.segmentKey,
            selectedBags: [],
          });
        });
      }

      updatedSelectedAddons.baggages = _.uniqBy(updatedSelectedAddons.baggages, 'segmentKey');
      return {
        ...state,
        selectedAddons: _.cloneDeep(updatedSelectedAddons),
      };
    case INIT_SEATS:
      const initSeatData = Array<any>();
      action.seats.forEach((seat: any) => {
        seat.availability.cabin.forEach((can: any) => {
          can.cabinSeatRowInfo.forEach((cabin: any) => {
            initSeatData.push({
              flightKey: can.flightKey,
              segmentKey: cabin.segmentRef,
              selectedSeats: [],
            });
          });
        });
      });
      const flightOrder: any = [];
      action.selectedFlightDetail.map((fd: any) => {
        const segmentAvail = initSeatData.find(o => _.isEqual(o, fd));
        flightOrder.push(fd.segmentKey);
        if (typeof segmentAvail === 'undefined') {
          const { flightKey, segmentKey } = fd;
          initSeatData.push({
            flightKey,
            segmentKey,
            selectedSeats: [],
          });
        }
      });
      const updateSeatOrder = _.sortBy(initSeatData, (o: any) => flightOrder.indexOf(o.segmentKey));
      (updatedSelectedAddons.seats as any) = [];
      (updatedSelectedAddons.seats as any).push(...updateSeatOrder);
      updatedSelectedAddons.seats = _.uniqBy(updatedSelectedAddons.seats, 'segmentKey');
      return {
        ...state,
        selectedAddons: _.cloneDeep(updatedSelectedAddons),
      };
    case SELECT_BAGGAGE:
      updatedSelectedAddons.baggages.forEach((_b: any, index: number) => {
        updatedSelectedAddons.baggages[index] = _.cloneDeep(
          selectedAddons.baggages[index],
        );
      });
      if (!selectedBags || selectedBags.length < 1) {
        selectedBags = [];
        selectedBags.push({
          paxKey: action.paxKey,
          baggage: [{
            baggageKey: action.baggageAvai.baggageKey,
            quantity: 1,
            type: action.baggageType,
            price: action.isPreset && !action.isUpdateQuantity
              ? 0 : action.baggageAvai.priceInfo.unitPrice,
            currency: action.baggageAvai.priceInfo.currency,
            weight: action.baggageAvai.weight,
          }],
        });
      } else {
        paxIndex = -1;
        selectedBags.forEach((b: any, index: number) => {
          if (b.paxKey === action.paxKey) paxIndex = index;
        });
        if (paxIndex === -1) {
          selectedBags.push({
            paxKey: action.paxKey,
            baggage: [{
              baggageKey: action.baggageAvai.baggageKey,
              quantity: 1,
              type: action.baggageType,
              price: action.isPreset && !action.isUpdateQuantity
                ? 0 : action.baggageAvai.priceInfo.unitPrice,
              currency: action.baggageAvai.priceInfo.currency,
              weight: action.baggageAvai.weight,
            }],
          });
        } else {
          const { baggageKey } = action.baggageAvai;
          let rmIdx = -1;
          selectedBags[paxIndex].baggage.forEach((b: any, index: number) => {
            if (b.baggageKey === baggageKey) rmIdx = index;
          });
          if (action.isPreset && action.quantity > 0) {
            if (rmIdx >= 0) {
              const previousQuantity = _.clone(selectedBags[paxIndex].baggage[rmIdx].quantity);
              selectedBags[paxIndex].baggage[rmIdx].quantity = action.quantity;
              selectedBags[paxIndex].baggage[rmIdx].price += (
                (action.quantity - previousQuantity)
                * action.baggageAvai.priceInfo.unitPrice
              );
            } else {
              selectedBags[paxIndex].baggage.push({
                baggageKey: action.baggageAvai.baggageKey,
                quantity: action.quantity,
                type: action.baggageType,
                price: action.baggageAvai.priceInfo.unitPrice * action.quantity,
                currency: action.baggageAvai.priceInfo.currency,
                weight: action.baggageAvai.weight,
              });
            }
          } else if (action.isPreset && (!action.quantity || action.quantity === 0)) {
            if (rmIdx >= 0) {
              selectedBags[paxIndex].baggage.splice(rmIdx, 1);
            } else {
              selectedBags[paxIndex].baggage.push({
                baggageKey: action.baggageAvai.baggageKey,
                quantity: 1,
                type: action.baggageType,
                price: 0,
                currency: action.baggageAvai.priceInfo.currency,
                weight: action.baggageAvai.weight,
              });
            }
          } else if (rmIdx >= 0 && !action.isPreset) {
            selectedBags[paxIndex].baggage.splice(rmIdx, 1);
          } else if ((action.isPreset && rmIdx === -1) || !action.isPreset) {
            selectedBags[paxIndex].baggage.push({
              baggageKey: action.baggageAvai.baggageKey,
              quantity: 1,
              type: action.baggageType,
              price: action.isPreset
                ? 0 : action.baggageAvai.priceInfo.unitPrice,
              currency: action.baggageAvai.priceInfo.currency,
              weight: action.baggageAvai.weight,
            });
          }
        }
      }

      if (sIndex === -1) {
        (updatedSelectedAddons.baggages as any).push({
          addonKey: action.baggageAvai.baggageKey || '',
          flightKey: action.segKey.flightKey || '',
          segmentKey: action.segKey.segmentKey || '',
          selectedBags: [...selectedBags],
        });
      } else {
        (updatedSelectedAddons.baggages[sIndex] as any) = {
          addonKey: action.baggageAvai.baggageKey || '',
          flightKey: action.segKey.flightKey || '',
          segmentKey: action.segKey.segmentKey || '',
          selectedBags: [...selectedBags],
        };
      }

      uppdatedTotalAddonsPrice.baggages.price = 0;
      updatedSelectedAddons.baggages.forEach((a: any) => {
        if (a && a.selectedBags && a.selectedBags.length >= 1) {
          a.selectedBags.forEach((b: any) => {
            if (b.baggage && b.baggage.length >= 1) {
              b.baggage.forEach((c: any) => {
                uppdatedTotalAddonsPrice.baggages.price += c.price;
                if (c.currency !== uppdatedTotalAddonsPrice.baggages.currency) {
                  uppdatedTotalAddonsPrice.baggages.currency = c.currency;
                }
              });
            }
          });
        }
      });

      return {
        ...state,
        selectedAddons: _.cloneDeep(updatedSelectedAddons),
        totalAddonsPrice: uppdatedTotalAddonsPrice,
      };
    case SELECT_SAME_BAGGAGE:
      paxIndex = -1;
      let replacedIndex = -1;
      const newSelectedBags = [
        ...(updatedSelectedAddons2.baggages[sIndex] as any).selectedBags,
      ];
      newSelectedBags.forEach((b: any, index: number) => {
        if (b.paxKey === action.paxKey) paxIndex = index;
      });
      if (paxIndex !== -1) {
        updatedSelectedAddons2.baggages.forEach((bag: any, index: number) => {
          if (index !== sIndex) {
            if (bag.selectedBags.length >= 1) {
              bag.selectedBags.forEach((s: any, i: number) => {
                if (s.paxKey === action.paxKey) replacedIndex = i;
              });

              if (replacedIndex !== -1) {
                bag.selectedBags[replacedIndex] = {};
                bag.selectedBags[replacedIndex] = { ...newSelectedBags[paxIndex] };
              } else {
                bag.selectedBags.push(newSelectedBags[paxIndex]);
              }
            } else {
              bag.selectedBags.push(newSelectedBags[paxIndex]);
            }
          }
        });
      }

      uppdatedTotalAddonsPrice.baggages.price = 0;
      updatedSelectedAddons2.baggages.forEach((a: any) => {
        if (a.selectedBags && a.selectedBags.length >= 1) {
          a.selectedBags.forEach((b: any) => {
            if (b.baggage && b.baggage.length >= 1) {
              b.baggage.forEach((c: any) => {
                uppdatedTotalAddonsPrice.baggages.price += c.price;
                if (c.currency !== uppdatedTotalAddonsPrice.baggages.currency) {
                  uppdatedTotalAddonsPrice.baggages.currency = c.currency;
                }
              });
            }
          });
        }
      });

      return {
        ...state,
        selectedAddons: _.cloneDeep(updatedSelectedAddons2),
        totalAddonsPrice: uppdatedTotalAddonsPrice,
      };
    case SELECT_BAGGAGE_ALL:
      updatedSelectedAddons.baggages.forEach((bag: any) => {
        if (bag.selectedBags && bag.selectedBags.length >= 1) {
          const defaultBag = _.find(
            bag.selectedBags,
            (segBag:any) => segBag.paxKey === action.allPaxArray[0],
          );
          const allPaxArr = bag.selectedBags.map((b: any) => b.paxKey);
          const missingPax1: string[] = [];
          const missingPax2: string[] = [];

          action.allPaxArray.forEach((pKey: any) => {
            if (allPaxArr.indexOf(pKey) === -1 && pKey !== defaultBag.paxKey) {
              missingPax1.push(pKey);
            }
          });
          allPaxArr.forEach((pKey: string) => {
            if (pKey !== defaultBag.paxKey) {
              missingPax2.push(pKey);
            }
          });

          missingPax1.forEach((pk: string) => {
            bag.selectedBags.push({
              ...defaultBag,
              paxKey: pk,
            });
          });

          missingPax2.forEach((pk: string) => {
            bag.selectedBags.forEach((b: any, i: number) => {
              if (b.paxKey === pk) {
                // eslint-disable-next-line no-param-reassign
                bag.selectedBags[i] = {
                  ...defaultBag,
                  paxKey: pk,
                };
              }
            });
          });
        }
      });
      uppdatedTotalAddonsPrice.baggages.price = 0;
      updatedSelectedAddons.baggages.forEach((a: any) => {
        if (a.selectedBags && a.selectedBags.length >= 1) {
          a.selectedBags.forEach((b: any) => {
            if (b.baggage && b.baggage.length >= 1) {
              b.baggage.forEach((c: any) => {
                uppdatedTotalAddonsPrice.baggages.price += c.price;
                if (c.currency !== uppdatedTotalAddonsPrice.baggages.currency) {
                  uppdatedTotalAddonsPrice.baggages.currency = c.currency;
                }
              });
            }
          });
        }
      });
      return {
        ...state,
        selectedAddons: _.cloneDeep(updatedSelectedAddons),
        totalAddonsPrice: uppdatedTotalAddonsPrice,
      };
    case REMOVE_ALL_BAGGAGES:
      paxIndex = -1;
      selectedBags.forEach((b: any, index: number) => {
        if (b.paxKey === action.paxKey) paxIndex = index;
      });
      if (paxIndex !== -1) {
        (updatedSelectedAddons
          .baggages[sIndex] as any).selectedBags[paxIndex] = [];
        if (action.isSelectSame) {
          updatedSelectedAddons
            .baggages.forEach((b: any, index: number) => {
              if (b && b.selectedBags && b.selectedBags.length >= 1) {
                b.selectedBags.forEach((bag: any, i: number) => {
                  if (bag.paxKey === action.paxKey) {
                    (updatedSelectedAddons.baggages[index] as any).selectedBags[i] = [];
                  }
                });
              }
            });
        }
      }
      uppdatedTotalAddonsPrice.baggages.price = 0;
      updatedSelectedAddons.baggages.forEach((a: any) => {
        if (a.selectedBags && a.selectedBags.length >= 1) {
          a.selectedBags.forEach((b: any) => {
            if (b.baggage && b.baggage.length >= 1) {
              b.baggage.forEach((c: any) => {
                uppdatedTotalAddonsPrice.baggages.price += c.price;
                if (c.currency !== uppdatedTotalAddonsPrice.baggages.currency) {
                  uppdatedTotalAddonsPrice.baggages.currency = c.currency;
                }
              });
            }
          });
        }
      });
      return {
        ...state,
        selectedAddons: _.cloneDeep(updatedSelectedAddons),
        totalAddonsPrice: uppdatedTotalAddonsPrice,
      };
    case SELECT_SEAT:
      if (updatedSelectedAddons.seats
        && updatedSelectedAddons.seats.length >= 1 && action.segKey) {
        updatedSelectedAddons.seats.forEach((b: any, index: number) => {
          if (b.flightKey === action.segKey.flightKey
            && b.segmentKey === action.segKey.segmentKey) sIndex = index;
        });
      }
      let { selectedSeats } = (updatedSelectedAddons.seats[sIndex] as any);
      if (!selectedSeats || selectedSeats.length < 1) {
        selectedSeats = [];
        selectedSeats.push({
          paxKey: action.paxKey,
          seatNo: action.addedSeat.seatNumber || '',
          quantity: 1,
          price: action.paxKey.split(/Child/g).length > 1 ? 0 : action.priceSeatSelected,
          currency: action.addedSeat.priceInfo.currency,
          rowType: action.rowType,
        });
      } else {
        paxIndex = -1;
        selectedSeats.forEach((b: any, index: number) => {
          if (b.paxKey === action.paxKey) paxIndex = index;
        });
        if (paxIndex === -1) {
          selectedSeats.push({
            paxKey: action.paxKey,
            seatNo: action.addedSeat.seatNumber || '',
            quantity: 1,
            price: action.paxKey.split(/Child/g).length > 1 ? 0 : action.priceSeatSelected,
            currency: action.addedSeat.priceInfo.currency,
            rowType: action.rowType,
          });
        } else if (action.isSeatRemoved) {
          selectedSeats[paxIndex].seatNo = '';
          selectedSeats[paxIndex].price = 0;
          selectedSeats[paxIndex].quantity = 0;
          selectedSeats[paxIndex].rowType = '';
        } else {
          selectedSeats[paxIndex].seatNo = action.addedSeat.seatNumber || '';
          selectedSeats[paxIndex].price = action.paxKey.split(/Child/g).length > 1 ? 0 : action.priceSeatSelected || 0;
          selectedSeats[paxIndex].quantity = 1;
          selectedSeats[paxIndex].rowType = action.rowType || '';
        }
      }
      (updatedSelectedAddons.seats[sIndex] as any) = {
        flightKey: action.segKey.flightKey || '',
        addonKey: action.seataddOnKey,
        segmentKey: action.segKey.segmentKey || '',
        selectedSeats,
      };

      uppdatedTotalAddonsPrice.seats.price = 0;
      updatedSelectedAddons.seats.forEach((a: any) => {
        if (a.selectedSeats && a.selectedSeats.length >= 1) {
          a.selectedSeats.forEach((b: any) => {
            uppdatedTotalAddonsPrice.seats.price += b.price;
            if (b.currency !== uppdatedTotalAddonsPrice.seats.currency) {
              uppdatedTotalAddonsPrice.seats.currency = b.currency;
            }
          });
        }
      });
      return {
        ...state,
        selectedAddons: updatedSelectedAddons,
        totalAddonsPrice: uppdatedTotalAddonsPrice,
      };
    case REMOVE_MEAL:
      let { selectedMeals } = (updatedSelectedAddons.meals[action.segIndex] as any);
      // paxIndex = -1;

      selectedMeals = _.filter(selectedMeals, (b: any) => b.paxKey !== action.paxKey);

      (updatedSelectedAddons.meals[action.segIndex] as any) = {
        addonKey: action.addedMeal.addonKey || '',
        flightKey: action.meals[action.segIndex].flightKey || '',
        segmentKey: action.meals[action.segIndex].segmentKey || '',
        selectedMeals,
      };

      uppdatedTotalAddonsPrice.meals.price = 0;
      updatedSelectedAddons.meals.forEach((a: any) => {
        if (a.selectedMeals && a.selectedMeals.length >= 1) {
          a.selectedMeals.forEach((b: any) => {
            uppdatedTotalAddonsPrice.meals.price += b.price;
            if (b.currency !== uppdatedTotalAddonsPrice.meals.currency) {
              uppdatedTotalAddonsPrice.meals.currency = b.currency;
            }
          });
        }
      });
      return {
        ...state,
        selectedAddons: _.cloneDeep(updatedSelectedAddons),
        totalAddonsPrice: uppdatedTotalAddonsPrice,
      };

    case SELECT_MEAL:
      ({ selectedMeals } = (updatedSelectedAddons.meals[action.segIndex] as any));
      if (!selectedMeals || selectedMeals.length < 1) {
        selectedMeals = [];
        selectedMeals.push({
          paxKey: action.paxKey || '',
          mealKey: action.addedMeal.ssrCode,
          quantity: 1,
          addonKey: action.addedMeal.addonKey,
          price: action.addedMeal.priceInfo.unitPrice,
          currency: action.addedMeal.priceInfo.currency,
          ssrName: action.addedMeal.ssrName,
        });
      } else {
        paxIndex = -1;
        selectedMeals.forEach((b: any, index: number) => {
          if (b.paxKey === action.paxKey) paxIndex = index;
        });
        if (paxIndex === -1) {
          selectedMeals.push({
            paxKey: action.paxKey || '',
            mealKey: action.addedMeal.ssrCode,
            quantity: 1,
            addonKey: action.addedMeal.addonKey,
            price: action.addedMeal.priceInfo.unitPrice,
            currency: action.addedMeal.priceInfo.currency,
            ssrName: action.addedMeal.ssrName,
          });
        } else {
          selectedMeals[paxIndex].paxKey = action.paxKey || '';
          selectedMeals[paxIndex].mealKey = action.addedMeal.ssrCode;
          selectedMeals[paxIndex].addonKey = action.addedMeal.addonKey;
          selectedMeals[paxIndex].price = action.addedMeal.priceInfo.unitPrice;
          selectedMeals[paxIndex].currency = action.addedMeal.priceInfo.currency;
          selectedMeals[paxIndex].quantity = 1;
          selectedMeals[paxIndex].ssrName = action.addedMeal.ssrName;
        }
      }

      (updatedSelectedAddons.meals[action.segIndex] as any) = {
        addonKey: action.addedMeal.addonKey || '',
        flightKey: action.meals[action.segIndex].flightKey || '',
        segmentKey: action.meals[action.segIndex].segmentKey || '',
        selectedMeals,
      };

      uppdatedTotalAddonsPrice.meals.price = 0;
      updatedSelectedAddons.meals.forEach((a: any) => {
        if (a.selectedMeals && a.selectedMeals.length >= 1) {
          a.selectedMeals.forEach((b: any) => {
            uppdatedTotalAddonsPrice.meals.price += b.price;
            if (b.currency !== uppdatedTotalAddonsPrice.meals.currency) {
              uppdatedTotalAddonsPrice.meals.currency = b.currency;
            }
          });
        }
      });
      return {
        ...state,
        selectedAddons: updatedSelectedAddons,
        totalAddonsPrice: uppdatedTotalAddonsPrice,
      };
    case REMOVE_SPCLREQUEST:
      let { selectedSSRAddons } = (updatedSelectedAddons.specialRequest[action.segIndex] as any);
      // paxIndex = -1;

      selectedSSRAddons = _.filter(selectedSSRAddons, (b: any) => b.paxKey !== action.paxKey);
      (updatedSelectedAddons.specialRequest[action.segIndex] as any) = {
        addonKey: action.addedSSR.addonKey || '',
        flightKey: action.allSpclReq[action.segIndex].flightKey || '',
        segmentKey: action.allSpclReq[action.segIndex].segmentKey || '',
        selectedSSRAddons,
      };
      return {
        ...state,
        selectedAddons: updatedSelectedAddons,
      };
    case SELECT_SPCLREQUEST:
      ({ selectedSSRAddons } = updatedSelectedAddons.specialRequest[action.segIndex] as any);
      if (!selectedSSRAddons || selectedSSRAddons.length < 1) {
        selectedSSRAddons = [];
        selectedSSRAddons.push({
          addonKey: action.addedSSR.addonKey,
          flightKey: action.flightKey,
          segmentKey: action.sSRSegmentKey,
          spclReqCode: action.spclReqCode,
          paxKey: action.paxKey || '',
        });
      } else {
        paxIndex = -1;
        selectedSSRAddons.forEach((b: any, index: number) => {
          if (b.paxKey === action.paxKey) paxIndex = index;
        });
        if (paxIndex === -1) {
          selectedSSRAddons.push({
            addonKey: action.addedSSR.addonKey,
            flightKey: action.flightKey,
            segmentKey: action.sSRSegmentKey,
            spclReqCode: action.spclReqCode,
            paxKey: action.paxKey || '',
          });
        } else {
          selectedSSRAddons[paxIndex].addonKey = action.addedSSR.addonKey;
          selectedSSRAddons[paxIndex].flightKey = action.flightKey;
          selectedSSRAddons[paxIndex].segmentKey = action.sSRSegmentKey;
          selectedSSRAddons[paxIndex].spclReqCode = action.spclReqCode;
          selectedSSRAddons[paxIndex].paxKey = action.paxKey || '';
        }
      }
      (updatedSelectedAddons.specialRequest[action.segIndex] as any) = {
        flightKey: action.flightKey || '',
        segmentKey: action.sSRSegmentKey || '',
        selectedSSRAddons,
      };
      return {
        ...state,
        selectedAddons: updatedSelectedAddons,
      };
    case SELECT_SERVICE:
      if (!(updatedSelectedAddons as any)[action.serviceType]) {
        (updatedSelectedAddons as any)[action.serviceType] = [
          [],
          [],
        ];
      }
      if (typeof action.service !== 'undefined') {
        (updatedSelectedAddons as any)[action.serviceType].push({
          addonKey: action.service.addonKey || '',
          flightKey: action.flightKey || '',
          segmentKey: action.service.segmentKey || '',
          paxKey: action.paxKey || '',
          paxIndex: action.service.paxIndex || '0',
          price: action.service.priceInfo.unitPrice,
          currency: action.service.priceInfo.currency,
          ssrName: action.service.ssrName,
          name: action.serviceName,
        });
      }

      if (!(uppdatedTotalAddonsPrice as any)[action.serviceType]) {
        (uppdatedTotalAddonsPrice as any)[action.serviceType] = { price: 0, currency: '' };
      }
      (uppdatedTotalAddonsPrice as any)[action.serviceType].price = 0;
      (updatedSelectedAddons as any)[action.serviceType].forEach((a: any) => {
        if (!_.isEmpty(a) && a.name !== 'Fare lock') {
          (uppdatedTotalAddonsPrice as any)[action.serviceType].price += a.price;
          if ((uppdatedTotalAddonsPrice as any)[action.serviceType].currency !== a.currency) {
            (uppdatedTotalAddonsPrice as any)[action.serviceType].currency = a.currency;
          }
        }
      });

      return {
        ...state,
        selectedAddons: updatedSelectedAddons,
        totalAddonsPrice: uppdatedTotalAddonsPrice,
      };
    case DESELECT_SERVICE_BY_SEGMENT:
      (updatedSelectedAddons as any)[action.serviceType] = _.reject(
        (updatedSelectedAddons as any)[action.serviceType],
        { paxKey: action.paxKey, segmentKey: action.segmentKey },
      );
      (uppdatedTotalAddonsPrice as any)[action.serviceType].price = 0;
      (uppdatedTotalAddonsPrice as any)[action.serviceType].currency = '';
      _.map((updatedSelectedAddons as any)[action.serviceType], (a: any) => {
        (uppdatedTotalAddonsPrice as any)[action.serviceType].price += a.price;
        if ((uppdatedTotalAddonsPrice as any)[action.serviceType].currency !== a.currency) {
          (uppdatedTotalAddonsPrice as any)[action.serviceType].currency = a.currency;
        }
      });
      return {
        ...state,
        selectedAddons: updatedSelectedAddons,
        totalAddonsPrice: uppdatedTotalAddonsPrice,
      };
    case DESELECT_SERVICE:
      (updatedSelectedAddons as any)[action.serviceType] = [];
      // if (!(uppdatedTotalAddonsPrice as any)[action.serviceType]) {
      (uppdatedTotalAddonsPrice as any)[action.serviceType] = { price: 0, currency: '' };
      // }
      return {
        ...state,
        selectedAddons: updatedSelectedAddons,
        totalAddonsPrice: uppdatedTotalAddonsPrice,
      };
    case SELECT_ADDONS_CLUB:
      if (typeof action.service !== 'undefined') {
        (updatedSelectedAddons as any)[action.serviceType] = [{
          name: action.serviceName,
          addonKey: action.service.addonKey,
          summaryKey: action.serviceType,
        }];
      }
      return {
        ...state,
        selectedAddons: updatedSelectedAddons,
      };
    case SELECT_SMS_SERVICE:
      if (typeof action.service !== 'undefined') {
        (updatedSelectedAddons as any)[action.serviceType].push({
          addonKey: action.service.addonKey || '',
          paxIndex: action.service.paxIndex || '0',
          price: action.service.priceInfo.unitPrice,
          currency: action.service.priceInfo.currency,
          ssrName: action.service.ssrName,
          name: action.serviceName,
        });
      }
      if (!(uppdatedTotalAddonsPrice as any)[action.serviceType]) {
        (uppdatedTotalAddonsPrice as any)[action.serviceType] = { price: 0, currency: '' };
      }
      (uppdatedTotalAddonsPrice as any)[action.serviceType].price = 0;
      (updatedSelectedAddons as any)[action.serviceType].forEach((a: any) => {
        (uppdatedTotalAddonsPrice as any)[action.serviceType].price += a.price;
        if ((uppdatedTotalAddonsPrice as any)[action.serviceType].currency !== a.currency) {
          (uppdatedTotalAddonsPrice as any)[action.serviceType].currency = a.currency;
        }
      });
      return {
        ...state,
        selectedAddons: updatedSelectedAddons,
        totalAddonsPrice: uppdatedTotalAddonsPrice,
      };
    case REMOVE_SERVICE:
      paxIndex = 0;
      (updatedSelectedAddons as any)[action.serviceType][action.isOutbound ? 0 : 1]
        .forEach((s: any, index: number) => {
          if (s.paxKey === action.paxKey) paxIndex = index;
        });
      (updatedSelectedAddons as any)[action.serviceType][
        action.isOutbound ? 0 : 1
      ].splice(paxIndex, 2);

      (uppdatedTotalAddonsPrice as any)[action.serviceType].price = 0;
      (updatedSelectedAddons as any)[action.serviceType].forEach((a: any) => {
        if (a && a.length >= 1) {
          a.forEach((b: any) => {
            (uppdatedTotalAddonsPrice as any)[action.serviceType].price += b.price;
            if ((uppdatedTotalAddonsPrice as any)[action.serviceType].currency !== b.currency) {
              (uppdatedTotalAddonsPrice as any)[action.serviceType].currency = b.currency;
            }
          });
        }
      });
      return {
        ...state,
        selectedAddons: updatedSelectedAddons,
        totalAddonsPrice: uppdatedTotalAddonsPrice,
      };
    case SET_IS_FETCHING:
      return {
        ...state,
        isFetching: action.isFetching,
      };
    case ADDONS_UNAVAILABLE:
      return {
        ...state,
        isAddonUnavail: action.isAddonUnavail,
        isAddonSearched: action.isAddonSearched,
        addonAvailabilityError: action.addonAvailabilityError,
        addonSearchResult: action.addonSearchResult,
      };
    case SET_ADDON_BAGGAGE_PAGE_SAME_BOTH_WAYS:
      _.map(BAGGAGE_PAGE_ADDONS, (baggagePageAddons: any) => {
        (uppdatedTotalAddonsPrice as any)[baggagePageAddons].price = 0;
        _.map((updatedSelectedAddons as any)[baggagePageAddons], (a: any) => {
          if (!_.isEmpty(a)) {
            (uppdatedTotalAddonsPrice as any)[baggagePageAddons].price += a.price;
            if ((uppdatedTotalAddonsPrice as any)[baggagePageAddons].currency !== a.currency) {
              (uppdatedTotalAddonsPrice as any)[baggagePageAddons].currency = a.currency;
            }
          }
        });
      });

      uppdatedTotalAddonsPrice.baggages.price = 0;
      updatedSelectedAddons.baggages.forEach((a: any) => {
        if (a.selectedBags && a.selectedBags.length >= 1) {
          a.selectedBags.forEach((b: any) => {
            if (b.baggage && b.baggage.length >= 1) {
              b.baggage.forEach((c: any) => {
                uppdatedTotalAddonsPrice.baggages.price += c.price;
                if (c.currency !== uppdatedTotalAddonsPrice.baggages.currency) {
                  uppdatedTotalAddonsPrice.baggages.currency = c.currency;
                }
              });
            }
          });
        }
      });
      return {
        ...state,
        selectedAddons,
        totalAddonsPrice: uppdatedTotalAddonsPrice,
      };
    case INIT_BOTHWAY_SETTINGS:
      return {
        ...state,
        sameForBothBaggagePaxSettings: action.sameForBothBaggagePaxSettings,
        bothPaxSettingsDone: action.bothPaxSettingsDone,
      };
    case UPDATE_BOTHWAY_SETTINGS:
      return {
        ...state,
        sameForBothBaggagePaxSettings: action.sameForBothBaggagePaxSettings,
      };
    default:
      return state;
  }
};
